



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.5.14">
    
    
      
        <title>Rpn - kerod</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.d3202873.min.css">
      
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.ff0a5ce4.min.css">
      
      
        
        
        <meta name="theme-color" content="#4cae4f">
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="green" data-md-color-accent="lightgreen">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-kerodmodeldetectionrpn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../../../../.." title="kerod" class="md-header-nav__button md-logo" aria-label="kerod">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            kerod
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Rpn
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/EmGarr/kerod/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    kerod
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="kerod" class="md-nav__button md-logo" aria-label="kerod">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    kerod
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/EmGarr/kerod/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    kerod
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../../../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../../../../CONTRIBUTING/" title="Contributing" class="md-nav__link">
      Contributing
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../../../../docs/BENCHMARKS/" title="Benchmarks" class="md-nav__link">
      Benchmarks
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Reference
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Reference" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon"></span>
        Reference
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1" type="checkbox" id="nav-4-1" checked>
    
    <label class="md-nav__link" for="nav-4-1">
      Kerod
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Kerod" data-md-level="2">
      <label class="md-nav__title" for="nav-4-1">
        <span class="md-nav__icon md-icon"></span>
        Kerod
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-2" type="checkbox" id="nav-4-1-2">
    
    <label class="md-nav__link" for="nav-4-1-2">
      Core
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Core" data-md-level="3">
      <label class="md-nav__title" for="nav-4-1-2">
        <span class="md-nav__icon md-icon"></span>
        Core
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/anchor_generator/" title="Anchor Generator" class="md-nav__link">
      Anchor Generator
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/box_coder/" title="Box Coder" class="md-nav__link">
      Box Coder
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/box_ops/" title="Box Ops" class="md-nav__link">
      Box Ops
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/constants/" title="Constants" class="md-nav__link">
      Constants
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/learning_rate_schedule/" title="Learning Rate Schedule" class="md-nav__link">
      Learning Rate Schedule
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/losses/" title="Losses" class="md-nav__link">
      Losses
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/matcher/" title="Matcher" class="md-nav__link">
      Matcher
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/sampling_ops/" title="Sampling Ops" class="md-nav__link">
      Sampling Ops
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/similarity/" title="Similarity" class="md-nav__link">
      Similarity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/standard_fields/" title="Standard Fields" class="md-nav__link">
      Standard Fields
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../core/target_assigner/" title="Target Assigner" class="md-nav__link">
      Target Assigner
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-3" type="checkbox" id="nav-4-1-3">
    
    <label class="md-nav__link" for="nav-4-1-3">
      Dataset
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Dataset" data-md-level="3">
      <label class="md-nav__title" for="nav-4-1-3">
        <span class="md-nav__icon md-icon"></span>
        Dataset
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dataset/augmentation/" title="Augmentation" class="md-nav__link">
      Augmentation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dataset/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../dataset/preprocessing/" title="Preprocessing" class="md-nav__link">
      Preprocessing
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-4" type="checkbox" id="nav-4-1-4" checked>
    
    <label class="md-nav__link" for="nav-4-1-4">
      Model
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Model" data-md-level="3">
      <label class="md-nav__title" for="nav-4-1-4">
        <span class="md-nav__icon md-icon"></span>
        Model
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../detr/" title="Detr" class="md-nav__link">
      Detr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../factory/" title="Factory" class="md-nav__link">
      Factory
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../faster_rcnn/" title="Faster Rcnn" class="md-nav__link">
      Faster Rcnn
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-4-5" type="checkbox" id="nav-4-1-4-5">
    
    <label class="md-nav__link" for="nav-4-1-4-5">
      Backbone
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Backbone" data-md-level="4">
      <label class="md-nav__title" for="nav-4-1-4-5">
        <span class="md-nav__icon md-icon"></span>
        Backbone
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../backbone/fpn/" title="Fpn" class="md-nav__link">
      Fpn
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../backbone/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../backbone/resnet/" title="Resnet" class="md-nav__link">
      Resnet
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-4-6" type="checkbox" id="nav-4-1-4-6" checked>
    
    <label class="md-nav__link" for="nav-4-1-4-6">
      Detection
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Detection" data-md-level="4">
      <label class="md-nav__title" for="nav-4-1-4-6">
        <span class="md-nav__icon md-icon"></span>
        Detection
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../abstract_detection_head/" title="Abstract Detection Head" class="md-nav__link">
      Abstract Detection Head
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../fast_rcnn/" title="Fast Rcnn" class="md-nav__link">
      Fast Rcnn
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../pooling_ops/" title="Pooling Ops" class="md-nav__link">
      Pooling Ops
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Rpn
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" title="Rpn" class="md-nav__link md-nav__link--active">
      Rpn
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#variables" class="md-nav__link">
    Variables
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#compute_rpn_metrics" class="md-nav__link">
    compute_rpn_metrics
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#regionproposalnetwork" class="md-nav__link">
    RegionProposalNetwork
  </a>
  
    <nav class="md-nav" aria-label="RegionProposalNetwork">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-methods" class="md-nav__link">
    Static methods
  </a>
  
    <nav class="md-nav" aria-label="Static methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#from_config" class="md-nav__link">
    from_config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with_name_scope" class="md-nav__link">
    with_name_scope
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-4-7" type="checkbox" id="nav-4-1-4-7">
    
    <label class="md-nav__link" for="nav-4-1-4-7">
      Layers
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Layers" data-md-level="4">
      <label class="md-nav__title" for="nav-4-1-4-7">
        <span class="md-nav__icon md-icon"></span>
        Layers
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../layers/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../layers/positional_encoding/" title="Positional Encoding" class="md-nav__link">
      Positional Encoding
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../layers/transformer/" title="Transformer" class="md-nav__link">
      Transformer
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-4-8" type="checkbox" id="nav-4-1-4-8">
    
    <label class="md-nav__link" for="nav-4-1-4-8">
      Post Processing
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Post Processing" data-md-level="4">
      <label class="md-nav__title" for="nav-4-1-4-8">
        <span class="md-nav__icon md-icon"></span>
        Post Processing
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../post_processing/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../post_processing/non_maximum_suppression/" title="Non Maximum Suppression" class="md-nav__link">
      Non Maximum Suppression
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../post_processing/post_processing_detr/" title="Post Processing Detr" class="md-nav__link">
      Post Processing Detr
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4-1-5" type="checkbox" id="nav-4-1-5">
    
    <label class="md-nav__link" for="nav-4-1-5">
      Utils
      <span class="md-nav__icon md-icon"></span>
    </label>
    <nav class="md-nav" aria-label="Utils" data-md-level="3">
      <label class="md-nav__title" for="nav-4-1-5">
        <span class="md-nav__icon md-icon"></span>
        Utils
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../utils/drawing/" title="Drawing" class="md-nav__link">
      Drawing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../utils/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../utils/ops/" title="Ops" class="md-nav__link">
      Ops
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../utils/training/" title="Training" class="md-nav__link">
      Training
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#variables" class="md-nav__link">
    Variables
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#compute_rpn_metrics" class="md-nav__link">
    compute_rpn_metrics
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#regionproposalnetwork" class="md-nav__link">
    RegionProposalNetwork
  </a>
  
    <nav class="md-nav" aria-label="RegionProposalNetwork">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-methods" class="md-nav__link">
    Static methods
  </a>
  
    <nav class="md-nav" aria-label="Static methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#from_config" class="md-nav__link">
    from_config
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with_name_scope" class="md-nav__link">
    with_name_scope
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/EmGarr/kerod/edit/master/reference/kerod/model/detection/rpn.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <h1 id="module-kerodmodeldetectionrpn">Module kerod.model.detection.rpn</h1>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="kn">as</span> <span class="nn">tf</span>

<span class="kn">import</span> <span class="nn">tensorflow.keras.layers</span> <span class="kn">as</span> <span class="nn">KL</span>

<span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">initializers</span>

<span class="kn">from</span> <span class="nn">tensorflow.keras.losses</span> <span class="kn">import</span> <span class="n">SparseCategoricalCrossentropy</span>

<span class="kn">from</span> <span class="nn">kerod.core.anchor_generator</span> <span class="kn">import</span> <span class="n">Anchors</span>

<span class="kn">from</span> <span class="nn">kerod.core.matcher</span> <span class="kn">import</span> <span class="n">Matcher</span>

<span class="kn">from</span> <span class="nn">kerod.core.box_coder</span> <span class="kn">import</span> <span class="n">encode_boxes_faster_rcnn</span>

<span class="kn">from</span> <span class="nn">kerod.core.losses</span> <span class="kn">import</span> <span class="n">L1Loss</span>

<span class="kn">from</span> <span class="nn">kerod.core.similarity</span> <span class="kn">import</span> <span class="n">IoUSimilarity</span>

<span class="kn">from</span> <span class="nn">kerod.core.sampling_ops</span> <span class="kn">import</span> <span class="n">batch_sample_balanced_positive_negative</span>

<span class="kn">from</span> <span class="nn">kerod.core.standard_fields</span> <span class="kn">import</span> <span class="n">BoxField</span>

<span class="kn">from</span> <span class="nn">kerod.core.target_assigner</span> <span class="kn">import</span> <span class="n">TargetAssigner</span>

<span class="kn">from</span> <span class="nn">kerod.model.detection.abstract_detection_head</span> <span class="kn">import</span> <span class="n">AbstractDetectionHead</span>

<span class="n">SAMPLING_SIZE</span> <span class="o">=</span> <span class="mi">256</span>

<span class="n">SAMPLING_POSITIVE_RATIO</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="k">class</span> <span class="nc">RegionProposalNetwork</span><span class="p">(</span><span class="n">AbstractDetectionHead</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;It has been introduced in the [Faster R-CNN paper](https://arxiv.org/abs/1506.01497) and</span>

<span class="sd">    use the parameters from [Feature Pyramidal Networks for Object Detection](https://arxiv.org/abs/1612.03144).</span>

<span class="sd">    Arguments:</span>

<span class="sd">    - *anchor_ratios*: The ratios are the different shapes that you want to apply on your anchors.</span>

<span class="sd">            e.g: (0.5, 1, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchor_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>

            <span class="mi">2</span><span class="p">,</span>

            <span class="n">SparseCategoricalCrossentropy</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">Reduction</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span>

                                          <span class="n">from_logits</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>

            <span class="n">L1Loss</span><span class="p">(</span><span class="n">reduction</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">Reduction</span><span class="o">.</span><span class="n">NONE</span><span class="p">),</span>

            <span class="n">multiples</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">anchor_ratios</span><span class="p">),</span>

            <span class="n">kernel_initializer_classification_head</span><span class="o">=</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="n">stddev</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>

            <span class="n">kernel_initializer_box_prediction_head</span><span class="o">=</span><span class="n">initializers</span><span class="o">.</span><span class="n">RandomNormal</span><span class="p">(</span><span class="n">stddev</span><span class="o">=</span><span class="mf">0.01</span><span class="p">),</span>

            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1">#Force each ground_truths to match to at least one anchor</span>

        <span class="n">matcher</span> <span class="o">=</span> <span class="n">Matcher</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">allow_low_quality_matches</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_assigner</span> <span class="o">=</span> <span class="n">TargetAssigner</span><span class="p">(</span><span class="n">IoUSimilarity</span><span class="p">(),</span>

                                              <span class="n">matcher</span><span class="p">,</span>

                                              <span class="n">encode_boxes_faster_rcnn</span><span class="p">,</span>

                                              <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_dtype</span><span class="p">)</span>

        <span class="n">anchor_strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

        <span class="n">anchor_zises</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_anchor_ratios</span> <span class="o">=</span> <span class="n">anchor_ratios</span>

        <span class="c1"># Precompute a deterministic grid of anchors for each layer of the pyramid.</span>

        <span class="c1"># We will extract a subpart of the anchors according to</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_anchors</span> <span class="o">=</span> <span class="p">[</span>

            <span class="n">Anchors</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchor_ratios</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">stride</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">anchor_strides</span><span class="p">,</span> <span class="n">anchor_zises</span><span class="p">)</span>

        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_conv2d</span> <span class="o">=</span> <span class="n">KL</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>

                                    <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>

                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_initializer_classification_head</span><span class="p">,</span>

                                    <span class="n">kernel_regularizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel_regularizer</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_rpn_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Predictions for the classification and the regression</span>

<span class="sd">        Arguments:</span>

<span class="sd">        - *inputs*: A tensor of  shape [batch_size, width, height, channel]</span>

<span class="sd">        Returns:</span>

<span class="sd">        A tuple of tensors of shape ([batch_size, num_anchors, 2], [batch_size, num_anchors, 4])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">inputs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">rpn_conv2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpn_conv2d</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">classification_head</span><span class="p">,</span> <span class="n">localization_head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_detection_head</span><span class="p">(</span><span class="n">rpn_conv2d</span><span class="p">)</span>

        <span class="n">classification_head</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">classification_head</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">localization_head</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">localization_head</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">classification_head</span><span class="p">,</span> <span class="n">localization_head</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]):</span>

        <span class="sd">&quot;&quot;&quot;Create the computation graph for the rpn inference</span>

<span class="sd">        Argument:</span>

<span class="sd">        *inputs*: A List of tensors the output of the pyramid</span>

<span class="sd">        Returns:</span>

<span class="sd">        - *localization_pred*: A list of logits 3-D tensor of shape [batch_size, num_anchors, 4]</span>

<span class="sd">        - *classification_pred*: A lost of logits 3-D tensor of shape [batch_size, num_anchors, 2]</span>

<span class="sd">        - *anchors*: A list of tensors of shape [batch_size, num_anchors, (y_min, x_min, y_max, x_max)]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="p">[</span><span class="n">anchors</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span> <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">anchors</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchors</span><span class="p">)]</span>

        <span class="n">rpn_predictions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">build_rpn_head</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span> <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="n">localization_pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">prediction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="n">rpn_predictions</span><span class="p">]</span>

        <span class="n">classification_pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">prediction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">prediction</span> <span class="ow">in</span> <span class="n">rpn_predictions</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">localization_pred</span><span class="p">,</span> <span class="n">classification_pred</span><span class="p">,</span> <span class="n">anchors</span>

    <span class="k">def</span> <span class="nf">compute_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localization_pred</span><span class="p">,</span> <span class="n">classification_pred</span><span class="p">,</span> <span class="n">anchors</span><span class="p">,</span> <span class="n">ground_truths</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Compute the loss</span>

<span class="sd">        Arguments:</span>

<span class="sd">        - *localization_pred*: A list of tensors of shape [batch_size, num_anchors, 4].</span>

<span class="sd">        - *classification_pred*: A list of tensors of shape [batch_size, num_anchors, 2]</span>

<span class="sd">        - *anchors*: A list of tensors of shape [num_anchors, (y_min, x_min, y_max, x_max)]</span>

<span class="sd">        - *ground_truths*: A dict with BoxField as key and a tensor as value.</span>

<span class="sd">        ```python</span>

<span class="sd">        ground_truths = {</span>

<span class="sd">            BoxField.BOXES:</span>

<span class="sd">                tf.constant([[[0, 0, 1, 1], [0, 0, 2, 2]], [[0, 0, 3, 3], [0, 0, 0, 0]]], tf.float32),</span>

<span class="sd">            BoxField.LABELS:</span>

<span class="sd">                tf.constant([[1, 0], [1, 0]], tf.float32),</span>

<span class="sd">            BoxField.WEIGHTS:</span>

<span class="sd">                tf.constant([[1, 0], [1, 1]], tf.float32),</span>

<span class="sd">            BoxField.NUM_BOXES:</span>

<span class="sd">                tf.constant([[2], [1]], tf.int32)</span>

<span class="sd">        }</span>

<span class="sd">        ```</span>

<span class="sd">        where `NUM_BOXES` allows to remove the padding created by tf.Data.</span>

<span class="sd">        Returns:</span>

<span class="sd">        - *classification_loss*: A scalar in tf.float32</span>

<span class="sd">        - *localization_loss*: A scalar in tf.float32</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">localization_pred</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">localization_pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">classification_pred</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">classification_pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">ground_truths</span> <span class="o">=</span> <span class="p">{</span>

            <span class="c1"># We add one because the background is not counted in ground_truths[BoxField.LABELS]</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">],</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">WEIGHTS</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">WEIGHTS</span><span class="p">],</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">NUM_BOXES</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">NUM_BOXES</span><span class="p">]</span>

        <span class="p">}</span>

        <span class="c1"># anchors are deterministic duplicate them to create a batch</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">anchors</span><span class="p">[</span><span class="bp">None</span><span class="p">],</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">y_true</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_assigner</span><span class="o">.</span><span class="n">assign</span><span class="p">({</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span> <span class="n">anchors</span><span class="p">},</span> <span class="n">ground_truths</span><span class="p">)</span>

        <span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">## Compute metrics</span>

        <span class="n">recall</span> <span class="o">=</span> <span class="n">compute_rpn_metrics</span><span class="p">(</span><span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">],</span> <span class="n">classification_pred</span><span class="p">,</span>

                                     <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">recall</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rpn_recall&#39;</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>

        <span class="c1"># All the boxes which are not -1 can be sampled</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">batch_sample_balanced_positive_negative</span><span class="p">(</span>

            <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">],</span>

            <span class="n">SAMPLING_SIZE</span><span class="p">,</span>

            <span class="n">labels</span><span class="p">,</span>

            <span class="n">positive_fraction</span><span class="o">=</span><span class="n">SAMPLING_POSITIVE_RATIO</span><span class="p">,</span>

            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_dtype</span><span class="p">)</span>

        <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span>

        <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">]</span>

        <span class="n">y_pred</span> <span class="o">=</span> <span class="p">{</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">:</span> <span class="n">classification_pred</span><span class="p">,</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span> <span class="n">localization_pred</span>

        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_losses</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">base_config</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_config</span><span class="p">()</span>

        <span class="n">base_config</span><span class="p">[</span><span class="s1">&#39;anchor_ratios&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchor_ratios</span>

        <span class="k">return</span> <span class="n">base_config</span>

<span class="k">def</span> <span class="nf">compute_rpn_metrics</span><span class="p">(</span><span class="n">y_true</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Useful metrics that allows to track how behave the training of the rpn head.</span>

<span class="sd">    Arguments:</span>

<span class="sd">    - *y_true*: A tensor vector with shape [batch_size, num_anchors] where 0 = background and</span>

<span class="sd">    1 = foreground.</span>

<span class="sd">    - *y_pred*: A tensor of shape [batch_size, num_anchors, 2],</span>

<span class="sd">    representing the classification logits.</span>

<span class="sd">    - *weights*: A tensor of shape [batch_size, num_anchors] where weights should</span>

<span class="sd">    Returns:</span>

<span class="sd">    - *recall*: Among all the boxes that we had to find how much did we found.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Force the cast to avoid type issue when the mixed precision is activated</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>

        <span class="n">weights</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Sometimes the weights have decimal value we do not want that</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">clip_by_value</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">masked_y_true</span> <span class="o">=</span> <span class="n">y_true</span> <span class="o">*</span> <span class="n">weights</span>

    <span class="n">prediction</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;label_prediction&#39;</span><span class="p">),</span>

                         <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights</span>  <span class="c1"># 0 or 1</span>

    <span class="n">correct</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">masked_y_true</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">fg_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masked_y_true</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">num_valid_anchor</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">masked_y_true</span><span class="p">)</span>

    <span class="n">num_pos_foreground_prediction</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">fg_inds</span><span class="p">))</span>

    <span class="n">recall</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">truediv</span><span class="p">(</span><span class="n">num_pos_foreground_prediction</span><span class="p">,</span> <span class="n">num_valid_anchor</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;recall&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">recall</span>
</code></pre></div>

</details>
<h2 id="variables">Variables</h2>
<div class="codehilite"><pre><span></span><code><span class="n">SAMPLING_POSITIVE_RATIO</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">SAMPLING_SIZE</span>
</code></pre></div>

<h2 id="functions">Functions</h2>
<h3 id="compute_rpn_metrics">compute_rpn_metrics</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_rpn_metrics</span><span class="p">(</span>
    <span class="n">y_true</span><span class="p">:</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">y_pred</span><span class="p">:</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span>
<span class="p">)</span>
</code></pre></div>

<p>Useful metrics that allows to track how behave the training of the rpn head.</p>
<p>Arguments:</p>
<ul>
<li><em>y_true</em>: A tensor vector with shape [batch_size, num_anchors] where 0 = background and
1 = foreground.</li>
<li><em>y_pred</em>: A tensor of shape [batch_size, num_anchors, 2],
representing the classification logits.</li>
<li><em>weights</em>: A tensor of shape [batch_size, num_anchors] where weights should</li>
</ul>
<p>Returns:</p>
<ul>
<li><em>recall</em>: Among all the boxes that we had to find how much did we found.</li>
</ul>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="n">def</span> <span class="n">compute_rpn_metrics</span><span class="p">(</span><span class="nl">y_true:</span> <span class="n">tf</span><span class="p">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nl">y_pred:</span> <span class="n">tf</span><span class="p">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nl">weights:</span> <span class="n">tf</span><span class="p">.</span><span class="n">Tensor</span><span class="p">)</span><span class="o">:</span>

    <span class="s">&quot;&quot;&quot;Useful metrics that allows to track how behave the training of the rpn head.</span>

    <span class="nl">Arguments:</span>

    <span class="o">-</span> <span class="o">*</span><span class="n">y_true</span><span class="o">*:</span> <span class="n">A</span> <span class="n">tensor</span> <span class="n">vector</span> <span class="n">with</span> <span class="n">shape</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span><span class="p">]</span> <span class="n">where</span> <span class="mh">0</span> <span class="o">=</span> <span class="n">background</span> <span class="k">and</span>

    <span class="mh">1</span> <span class="o">=</span> <span class="n">foreground</span><span class="p">.</span>

    <span class="o">-</span> <span class="o">*</span><span class="n">y_pred</span><span class="o">*:</span> <span class="n">A</span> <span class="n">tensor</span> <span class="n">of</span> <span class="n">shape</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span><span class="p">,</span> <span class="mh">2</span><span class="p">],</span>

    <span class="n">representing</span> <span class="n">the</span> <span class="n">classification</span> <span class="n">logits</span><span class="p">.</span>

    <span class="o">-</span> <span class="o">*</span><span class="n">weights</span><span class="o">*:</span> <span class="n">A</span> <span class="n">tensor</span> <span class="n">of</span> <span class="n">shape</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span><span class="p">]</span> <span class="n">where</span> <span class="n">weights</span> <span class="n">should</span>

    <span class="nl">Returns:</span>

    <span class="o">-</span> <span class="o">*</span><span class="n">recall</span><span class="o">*:</span> <span class="n">Among</span> <span class="n">all</span> <span class="n">the</span> <span class="n">boxes</span> <span class="n">that</span> <span class="n">we</span> <span class="n">had</span> <span class="n">to</span> <span class="n">find</span> <span class="n">how</span> <span class="n">much</span> <span class="n">did</span> <span class="n">we</span> <span class="n">found</span><span class="p">.</span>

    <span class="s">&quot;&quot;&quot;</span>

    <span class="p">#</span> <span class="n">Force</span> <span class="n">the</span> <span class="n">cast</span> <span class="n">to</span> <span class="n">avoid</span> <span class="k">type</span> <span class="n">issue</span> <span class="n">when</span> <span class="n">the</span> <span class="n">mixed</span> <span class="n">precision</span> <span class="n">is</span> <span class="n">activated</span>

    <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span>

        <span class="n">weights</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="p">#</span> <span class="n">Sometimes</span> <span class="n">the</span> <span class="n">weights</span> <span class="n">have</span> <span class="n">decimal</span> <span class="n">value</span> <span class="n">we</span> <span class="k">do</span> <span class="k">not</span> <span class="n">want</span> <span class="n">that</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">clip_by_value</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="mh">0</span><span class="p">,</span> <span class="mh">1</span><span class="p">)</span>

    <span class="n">masked_y_true</span> <span class="o">=</span> <span class="n">y_true</span> <span class="o">*</span> <span class="n">weights</span>

    <span class="n">prediction</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mh">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="p">&#39;</span><span class="n">label_prediction</span><span class="p">&#39;),</span>

                         <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights</span>  <span class="p">#</span> <span class="mh">0</span> <span class="k">or</span> <span class="mh">1</span>

    <span class="n">correct</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">masked_y_true</span><span class="p">),</span> <span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">fg_inds</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">masked_y_true</span> <span class="o">==</span> <span class="mh">1</span><span class="p">)</span>

    <span class="n">num_valid_anchor</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">masked_y_true</span><span class="p">)</span>

    <span class="n">num_pos_foreground_prediction</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">fg_inds</span><span class="p">))</span>

    <span class="n">recall</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">truediv</span><span class="p">(</span><span class="n">num_pos_foreground_prediction</span><span class="p">,</span> <span class="n">num_valid_anchor</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="p">&#39;</span><span class="n">recall</span><span class="p">&#39;)</span>

    <span class="k">return</span> <span class="n">recall</span>
</code></pre></div>

</details>
<h2 id="classes">Classes</h2>
<h3 id="regionproposalnetwork">RegionProposalNetwork</h3>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">RegionProposalNetwork</span><span class="p">(</span>
    <span class="n">anchor_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>

<p>It has been introduced in the <a href="https://arxiv.org/abs/1506.01497">Faster R-CNN paper</a> and
use the parameters from <a href="https://arxiv.org/abs/1612.03144">Feature Pyramidal Networks for Object Detection</a>.</p>
<p>Arguments:</p>
<ul>
<li><em>anchor_ratios</em>: The ratios are the different shapes that you want to apply on your anchors.
        e.g: (0.5, 1, 2)</li>
</ul>
<h4 id="ancestors-in-mro">Ancestors (in MRO)</h4>
<ul>
<li>kerod.model.detection.abstract_detection_head.AbstractDetectionHead</li>
<li>tensorflow.python.keras.engine.base_layer.Layer</li>
<li>tensorflow.python.module.module.Module</li>
<li>tensorflow.python.training.tracking.tracking.AutoTrackable</li>
<li>tensorflow.python.training.tracking.base.Trackable</li>
<li>tensorflow.python.keras.utils.version_utils.LayerVersionSelector</li>
</ul>
<h4 id="static-methods">Static methods</h4>
<h5 id="from_config">from_config</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span>
    <span class="n">config</span>
<span class="p">)</span>
</code></pre></div>

<p>Creates a layer from its config.</p>
<p>This method is the reverse of <code>get_config</code>,
capable of instantiating the same layer from the config
dictionary. It does not handle layer connectivity
(handled by Network), nor weights (handled by <code>set_weights</code>).</p>
<p>Arguments:
    config: A Python dictionary, typically the
        output of get_config.</p>
<p>Returns:
    A layer instance.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@classmethod</span>

  <span class="n">def</span> <span class="n">from_config</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Creates a layer from its config.</span>

<span class="s2">    This method is the reverse of `get_config`,</span>

<span class="s2">    capable of instantiating the same layer from the config</span>

<span class="s2">    dictionary. It does not handle layer connectivity</span>

<span class="s2">    (handled by Network), nor weights (handled by `set_weights`).</span>

<span class="s2">    Arguments:</span>

<span class="s2">        config: A Python dictionary, typically the</span>

<span class="s2">            output of get_config.</span>

<span class="s2">    Returns:</span>

<span class="s2">        A layer instance.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="with_name_scope">with_name_scope</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">with_name_scope</span><span class="p">(</span>
    <span class="n">method</span>
<span class="p">)</span>
</code></pre></div>

<p>Decorator to automatically enter the module name scope.</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MyModule(tf.Module):
...   @tf.Module.with_name_scope
...   def <strong>call</strong>(self, x):
...     if not hasattr(self, 'w'):
...       self.w = tf.Variable(tf.random.normal([x.shape[1], 3]))
...     return tf.matmul(x, self.w)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Using the above module would produce <code>tf.Variable</code>s and <code>tf.Tensor</code>s whose
names included the module name:</p>
<blockquote>
<blockquote>
<blockquote>
<p>mod = MyModule()
mod(tf.ones([1, 2]))
<tf.Tensor: shape=(1, 3), dtype=float32, numpy=..., dtype=float32)>
mod.w
<tf.Variable 'my_module/Variable:0' shape=(2, 3) dtype=float32,
numpy=..., dtype=float32)></p>
</blockquote>
</blockquote>
</blockquote>
<p>Args:
  method: The method to wrap.</p>
<p>Returns:
  The original method wrapped such that it enters the module's name scope.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@classmethod</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">with_name_scope</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="w"> </span><span class="k">method</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Decorator to automatically enter the module name scope.</span>

<span class="ss">    &gt;&gt;&gt; class MyModule(tf.Module):</span>

<span class="ss">    ...   @tf.Module.with_name_scope</span>

<span class="ss">    ...   def __call__(self, x):</span>

<span class="ss">    ...     if not hasattr(self, &#39;w&#39;):</span>

<span class="ss">    ...       self.w = tf.Variable(tf.random.normal([x.shape[1], 3]))</span>

<span class="ss">    ...     return tf.matmul(x, self.w)</span>

<span class="ss">    Using the above module would produce `tf.Variable`s and `tf.Tensor`s whose</span>

<span class="ss">    names included the module name:</span>

<span class="ss">    &gt;&gt;&gt; mod = MyModule()</span>

<span class="ss">    &gt;&gt;&gt; mod(tf.ones([1, 2]))</span>

<span class="ss">    &lt;tf.Tensor: shape=(1, 3), dtype=float32, numpy=..., dtype=float32)&gt;</span>

<span class="ss">    &gt;&gt;&gt; mod.w</span>

<span class="ss">    &lt;tf.Variable &#39;my_module/Variable:0&#39; shape=(2, 3) dtype=float32,</span>

<span class="ss">    numpy=..., dtype=float32)&gt;</span>

<span class="ss">    Args:</span>

<span class="ss">      method: The method to wrap.</span>

<span class="ss">    Returns:</span>

<span class="ss">      The original method wrapped such that it enters the module&#39;s name scope.</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">method_with_name_scope</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">      </span><span class="k">with</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nl">name_scope</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">method</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tf_decorator</span><span class="p">.</span><span class="n">make_decorator</span><span class="p">(</span><span class="k">method</span><span class="p">,</span><span class="w"> </span><span class="n">method_with_name_scope</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h4 id="instance-variables">Instance variables</h4>
<div class="codehilite"><pre><span></span><code><span class="n">activity_regularizer</span>
</code></pre></div>

<p>Optional regularizer function for the output of this layer.</p>
<div class="codehilite"><pre><span></span><code><span class="n">compute_dtype</span>
</code></pre></div>

<p>The dtype of the layer's computations.</p>
<p>This is equivalent to <code>Layer.dtype_policy.compute_dtype</code>. Unless
mixed precision is used, this is the same as <code>Layer.dtype</code>, the dtype of
the weights.</p>
<p>Layers automatically cast their inputs to the compute dtype, which causes
computations and the output to be in the compute dtype as well. This is done
by the base Layer class in <code>Layer.__call__</code>, so you do not have to insert
these casts if implementing your own layer.</p>
<p>Layers often perform certain internal computations in higher precision when
<code>compute_dtype</code> is float16 or bfloat16 for numeric stability. The output
will still typically be float16 or bfloat16 in such cases.</p>
<p>Returns:
  The layer's compute dtype.</p>
<div class="codehilite"><pre><span></span><code><span class="n">dtype</span>
</code></pre></div>

<p>The dtype of the layer weights.</p>
<p>This is equivalent to <code>Layer.dtype_policy.variable_dtype</code>. Unless
mixed precision is used, this is the same as <code>Layer.compute_dtype</code>, the
dtype of the layer's computations.</p>
<div class="codehilite"><pre><span></span><code><span class="n">dtype_policy</span>
</code></pre></div>

<p>The dtype policy associated with this layer.</p>
<p>This is an instance of a <code>tf.keras.mixed_precision.Policy</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="n">dynamic</span>
</code></pre></div>

<p>Whether the layer is dynamic (eager-only); set in the constructor.</p>
<div class="codehilite"><pre><span></span><code><span class="n">inbound_nodes</span>
</code></pre></div>

<p>Deprecated, do NOT use! Only for compatibility with external Keras.</p>
<div class="codehilite"><pre><span></span><code><span class="nb">input</span>
</code></pre></div>

<p>Retrieves the input tensor(s) of a layer.</p>
<p>Only applicable if the layer has exactly one input,
i.e. if it is connected to one incoming layer.</p>
<p>Returns:
    Input tensor or list of input tensors.</p>
<p>Raises:
  RuntimeError: If called in Eager mode.
  AttributeError: If no inbound nodes are found.</p>
<div class="codehilite"><pre><span></span><code><span class="n">input_mask</span>
</code></pre></div>

<p>Retrieves the input mask tensor(s) of a layer.</p>
<p>Only applicable if the layer has exactly one inbound node,
i.e. if it is connected to one incoming layer.</p>
<p>Returns:
    Input mask tensor (potentially None) or list of input
    mask tensors.</p>
<p>Raises:
    AttributeError: if the layer is connected to
    more than one incoming layers.</p>
<div class="codehilite"><pre><span></span><code><span class="n">input_shape</span>
</code></pre></div>

<p>Retrieves the input shape(s) of a layer.</p>
<p>Only applicable if the layer has exactly one input,
i.e. if it is connected to one incoming layer, or if all inputs
have the same shape.</p>
<p>Returns:
    Input shape, as an integer shape tuple
    (or list of shape tuples, one tuple per input tensor).</p>
<p>Raises:
    AttributeError: if the layer has no defined input_shape.
    RuntimeError: if called in Eager mode.</p>
<div class="codehilite"><pre><span></span><code><span class="n">input_spec</span>
</code></pre></div>

<p><code>InputSpec</code> instance(s) describing the input format for this layer.</p>
<p>When you create a layer subclass, you can set <code>self.input_spec</code> to enable
the layer to run input compatibility checks when it is called.
Consider a <code>Conv2D</code> layer: it can only be called on a single input tensor
of rank 4. As such, you can set, in <code>__init__()</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">input_spec</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">InputSpec</span><span class="p">(</span><span class="n">ndim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div>

<p>Now, if you try to call the layer on an input that isn't rank 4
(for instance, an input of shape <code>(2,)</code>, it will raise a nicely-formatted
error:</p>
<div class="codehilite"><pre><span></span><code><span class="n">ValueError</span><span class="o">:</span> <span class="n">Input</span> <span class="mi">0</span> <span class="n">of</span> <span class="n">layer</span> <span class="n">conv2d</span> <span class="k">is</span> <span class="n">incompatible</span> <span class="k">with</span> <span class="n">the</span> <span class="n">layer</span><span class="o">:</span>
<span class="n">expected</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">4</span><span class="o">,</span> <span class="n">found</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="o">.</span> <span class="n">Full</span> <span class="n">shape</span> <span class="n">received</span><span class="o">:</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</code></pre></div>

<p>Input checks that can be specified via <code>input_spec</code> include:
- Structure (e.g. a single input, a list of 2 inputs, etc)
- Shape
- Rank (ndim)
- Dtype</p>
<p>For more information, see <code>tf.keras.layers.InputSpec</code>.</p>
<p>Returns:
  A <code>tf.keras.layers.InputSpec</code> instance, or nested structure thereof.</p>
<div class="codehilite"><pre><span></span><code><span class="n">losses</span>
</code></pre></div>

<p>List of losses added using the <code>add_loss()</code> API.</p>
<p>Variable regularization tensors are created when this property is accessed,
so it is eager safe: accessing <code>losses</code> under a <code>tf.GradientTape</code> will
propagate gradients back to the corresponding variables.</p>
<p>Examples:</p>
<blockquote>
<blockquote>
<blockquote>
<p>class MyLayer(tf.keras.layers.Layer):
...   def call(self, inputs):
...     self.add_loss(tf.abs(tf.reduce_mean(inputs)))
...     return inputs
l = MyLayer()
l(np.ones((10, 1)))
l.losses
[1.0]</p>
<p>inputs = tf.keras.Input(shape=(10,))
x = tf.keras.layers.Dense(10)(inputs)
outputs = tf.keras.layers.Dense(1)(x)
model = tf.keras.Model(inputs, outputs)</p>
<h1 id="activity-regularization">Activity regularization.</h1>
<p>len(model.losses)
0
model.add_loss(tf.abs(tf.reduce_mean(x)))
len(model.losses)
1</p>
<p>inputs = tf.keras.Input(shape=(10,))
d = tf.keras.layers.Dense(10, kernel_initializer='ones')
x = d(inputs)
outputs = tf.keras.layers.Dense(1)(x)
model = tf.keras.Model(inputs, outputs)</p>
<h1 id="weight-regularization">Weight regularization.</h1>
<p>model.add_loss(lambda: tf.reduce_mean(d.kernel))
model.losses
[<tf.Tensor: shape=(), dtype=float32, numpy=1.0>]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Returns:
  A list of tensors.</p>
<div class="codehilite"><pre><span></span><code><span class="n">metrics</span>
</code></pre></div>

<p>List of metrics added using the <code>add_metric()</code> API.</p>
<p>Example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>input = tf.keras.layers.Input(shape=(3,))
d = tf.keras.layers.Dense(2)
output = d(input)
d.add_metric(tf.reduce_max(output), name='max')
d.add_metric(tf.reduce_min(output), name='min')
[m.name for m in d.metrics]
['max', 'min']</p>
</blockquote>
</blockquote>
</blockquote>
<p>Returns:
  A list of <code>Metric</code> objects.</p>
<div class="codehilite"><pre><span></span><code><span class="n">name</span>
</code></pre></div>

<p>Name of the layer (string), set in the constructor.</p>
<div class="codehilite"><pre><span></span><code><span class="n">name_scope</span>
</code></pre></div>

<p>Returns a <code>tf.name_scope</code> instance for this class.</p>
<div class="codehilite"><pre><span></span><code><span class="n">non_trainable_variables</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">non_trainable_weights</span>
</code></pre></div>

<p>List of all non-trainable weights tracked by this layer.</p>
<p>Non-trainable weights are <em>not</em> updated during training. They are expected
to be updated manually in <code>call()</code>.</p>
<p>Note: This will not track the weights of nested <code>tf.Modules</code> that are not
themselves Keras layers.</p>
<p>Returns:
  A list of non-trainable variables.</p>
<div class="codehilite"><pre><span></span><code><span class="n">outbound_nodes</span>
</code></pre></div>

<p>Deprecated, do NOT use! Only for compatibility with external Keras.</p>
<div class="codehilite"><pre><span></span><code><span class="n">output</span>
</code></pre></div>

<p>Retrieves the output tensor(s) of a layer.</p>
<p>Only applicable if the layer has exactly one output,
i.e. if it is connected to one incoming layer.</p>
<p>Returns:
  Output tensor or list of output tensors.</p>
<p>Raises:
  AttributeError: if the layer is connected to more than one incoming
    layers.
  RuntimeError: if called in Eager mode.</p>
<div class="codehilite"><pre><span></span><code><span class="n">output_mask</span>
</code></pre></div>

<p>Retrieves the output mask tensor(s) of a layer.</p>
<p>Only applicable if the layer has exactly one inbound node,
i.e. if it is connected to one incoming layer.</p>
<p>Returns:
    Output mask tensor (potentially None) or list of output
    mask tensors.</p>
<p>Raises:
    AttributeError: if the layer is connected to
    more than one incoming layers.</p>
<div class="codehilite"><pre><span></span><code><span class="n">output_shape</span>
</code></pre></div>

<p>Retrieves the output shape(s) of a layer.</p>
<p>Only applicable if the layer has one output,
or if all outputs have the same shape.</p>
<p>Returns:
    Output shape, as an integer shape tuple
    (or list of shape tuples, one tuple per output tensor).</p>
<p>Raises:
    AttributeError: if the layer has no defined output shape.
    RuntimeError: if called in Eager mode.</p>
<div class="codehilite"><pre><span></span><code><span class="n">stateful</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">submodules</span>
</code></pre></div>

<p>Sequence of all sub-modules.</p>
<p>Submodules are modules which are properties of this module, or found as
properties of modules which are properties of this module (and so on).</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = tf.Module()
b = tf.Module()
c = tf.Module()
a.b = b
b.c = c
list(a.submodules) == [b, c]
True
list(b.submodules) == [c]
True
list(c.submodules) == []
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>Returns:
  A sequence of all submodules.</p>
<div class="codehilite"><pre><span></span><code><span class="n">supports_masking</span>
</code></pre></div>

<p>Whether this layer supports computing a mask using <code>compute_mask</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="n">trainable</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">trainable_variables</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">trainable_weights</span>
</code></pre></div>

<p>List of all trainable weights tracked by this layer.</p>
<p>Trainable weights are updated via gradient descent during training.</p>
<p>Note: This will not track the weights of nested <code>tf.Modules</code> that are not
themselves Keras layers.</p>
<p>Returns:
  A list of trainable variables.</p>
<div class="codehilite"><pre><span></span><code><span class="n">updates</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">variable_dtype</span>
</code></pre></div>

<p>Alias of <code>Layer.dtype</code>, the dtype of the weights.</p>
<div class="codehilite"><pre><span></span><code><span class="n">variables</span>
</code></pre></div>

<p>Returns the list of all layer variables/weights.</p>
<p>Alias of <code>self.weights</code>.</p>
<p>Note: This will not track the weights of nested <code>tf.Modules</code> that are not
themselves Keras layers.</p>
<p>Returns:
  A list of variables.</p>
<div class="codehilite"><pre><span></span><code><span class="n">weights</span>
</code></pre></div>

<p>Returns the list of all layer variables/weights.</p>
<p>Note: This will not track the weights of nested <code>tf.Modules</code> that are not
themselves Keras layers.</p>
<p>Returns:
  A list of variables.</p>
<h4 id="methods">Methods</h4>
<h5 id="add_loss">add_loss</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">add_loss</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">losses</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>

<p>Add loss tensor(s), potentially dependent on layer inputs.</p>
<p>Some losses (for instance, activity regularization losses) may be dependent
on the inputs passed when calling a layer. Hence, when reusing the same
layer on different inputs <code>a</code> and <code>b</code>, some entries in <code>layer.losses</code> may
be dependent on <code>a</code> and some on <code>b</code>. This method automatically keeps track
of dependencies.</p>
<p>This method can be used inside a subclassed layer or model's <code>call</code>
function, in which case <code>losses</code> should be a Tensor or list of Tensors.</p>
<p>Example:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">MyLayer</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_loss</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">inputs</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">inputs</span>
</code></pre></div>

<p>This method can also be called directly on a Functional Model during
construction. In this case, any loss Tensors passed to this Model must
be symbolic and be able to be traced back to the model's <code>Input</code>s. These
losses become part of the model's topology and are tracked in <code>get_config</code>.</p>
<p>Example:</p>
<div class="codehilite"><pre><span></span><code><span class="n">inputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
<span class="c1"># Activity regularization.</span>
<span class="n">model</span><span class="o">.</span><span class="n">add_loss</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
</code></pre></div>

<p>If this is not the case for your loss (if, for example, your loss references
a <code>Variable</code> of one of the model's layers), you can wrap your loss in a
zero-argument lambda. These losses are not tracked as part of the model's
topology since they can't be serialized.</p>
<p>Example:</p>
<div class="codehilite"><pre><span></span><code><span class="n">inputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
<span class="c1"># Weight regularization.</span>
<span class="n">model</span><span class="o">.</span><span class="n">add_loss</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">kernel</span><span class="p">))</span>
</code></pre></div>

<p>Arguments:
  losses: Loss tensor, or list/tuple of tensors. Rather than tensors, losses
    may also be zero-argument callables which create a loss tensor.
  **kwargs: Additional keyword arguments for backward compatibility.
    Accepted values:
      inputs - Deprecated, will be automatically inferred.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">add_loss</span>(<span class="nb">self</span>, <span class="n">losses</span>, **<span class="n">kwargs</span>):

    <span class="s">&quot;&quot;&quot;Add loss tensor(s), potentially dependent on layer inputs.</span>

<span class="s">    Some losses (for instance, activity regularization losses) may be dependent</span>

<span class="s">    on the inputs passed when calling a layer. Hence, when reusing the same</span>

<span class="s">    layer on different inputs `a` and `b`, some entries in `layer.losses` may</span>

<span class="s">    be dependent on `a` and some on `b`. This method automatically keeps track</span>

<span class="s">    of dependencies.</span>

<span class="s">    This method can be used inside a subclassed layer or model&#39;s `call`</span>

<span class="s">    function, in which case `losses` should be a Tensor or list of Tensors.</span>

<span class="s">    Example:</span>

<span class="s">    ```python</span>

<span class="s">    class MyLayer(tf.keras.layers.Layer):</span>

<span class="s">      def call(self, inputs):</span>

<span class="s">        self.add_loss(tf.abs(tf.reduce_mean(inputs)))</span>

<span class="s">        return inputs</span>

<span class="s">    ```</span>

<span class="s">    This method can also be called directly on a Functional Model during</span>

<span class="s">    construction. In this case, any loss Tensors passed to this Model must</span>

<span class="s">    be symbolic and be able to be traced back to the model&#39;s `Input`s. These</span>

<span class="s">    losses become part of the model&#39;s topology and are tracked in `get_config`.</span>

<span class="s">    Example:</span>

<span class="s">    ```python</span>

<span class="s">    inputs = tf.keras.Input(shape=(10,))</span>

<span class="s">    x = tf.keras.layers.Dense(10)(inputs)</span>

<span class="s">    outputs = tf.keras.layers.Dense(1)(x)</span>

<span class="s">    model = tf.keras.Model(inputs, outputs)</span>

<span class="s">    # Activity regularization.</span>

<span class="s">    model.add_loss(tf.abs(tf.reduce_mean(x)))</span>

<span class="s">    ```</span>

<span class="s">    If this is not the case for your loss (if, for example, your loss references</span>

<span class="s">    a `Variable` of one of the model&#39;s layers), you can wrap your loss in a</span>

<span class="s">    zero-argument lambda. These losses are not tracked as part of the model&#39;s</span>

<span class="s">    topology since they can&#39;t be serialized.</span>

<span class="s">    Example:</span>

<span class="s">    ```python</span>

<span class="s">    inputs = tf.keras.Input(shape=(10,))</span>

<span class="s">    d = tf.keras.layers.Dense(10)</span>

<span class="s">    x = d(inputs)</span>

<span class="s">    outputs = tf.keras.layers.Dense(1)(x)</span>

<span class="s">    model = tf.keras.Model(inputs, outputs)</span>

<span class="s">    # Weight regularization.</span>

<span class="s">    model.add_loss(lambda: tf.reduce_mean(d.kernel))</span>

<span class="s">    ```</span>

<span class="s">    Arguments:</span>

<span class="s">      losses: Loss tensor, or list/tuple of tensors. Rather than tensors, losses</span>

<span class="s">        may also be zero-argument callables which create a loss tensor.</span>

<span class="s">      **kwargs: Additional keyword arguments for backward compatibility.</span>

<span class="s">        Accepted values:</span>

<span class="s">          inputs - Deprecated, will be automatically inferred.</span>

<span class="s">    &quot;&quot;&quot;</span>

    <span class="n">kwargs</span>.<span class="nb">pop</span>(<span class="s">&#39;inputs&#39;</span>, <span class="n">None</span>)

    <span class="k">if</span> <span class="n">kwargs:</span>

      <span class="n">raise</span> <span class="n">TypeError</span>(<span class="s">&#39;Unknown keyword arguments: %s&#39;</span> % (<span class="n">kwargs</span>.<span class="nb">keys</span>(),))

    <span class="n">def</span> <span class="n">_tag_callable</span>(<span class="n">loss</span>):

      <span class="s">&quot;&quot;&quot;Tags callable loss tensor as `_unconditional_loss`.&quot;&quot;&quot;</span>

      <span class="k">if</span> <span class="n">callable</span>(<span class="n">loss</span>):

        <span class="c1"># We run the loss without autocasting, as regularizers are often</span>

        <span class="c1"># numerically unstable in float16.</span>

        <span class="k">with</span> <span class="n">autocast_variable</span>.<span class="n">enable_auto_cast_variables</span>(<span class="n">None</span>):

          <span class="n">loss</span> = <span class="n">loss</span>()

      <span class="k">if</span> <span class="n">loss</span> <span class="k">is</span> <span class="n">None:</span>

        <span class="k">return</span> <span class="n">None</span>  <span class="c1"># Will be filtered out when computing the .losses property</span>

      <span class="k">if</span> <span class="nb">not</span> <span class="n">tensor_util</span>.<span class="n">is_tensor</span>(<span class="n">loss</span>):

        <span class="n">loss</span> = <span class="n">ops</span>.<span class="n">convert_to_tensor_v2_with_dispatch</span>(

            <span class="n">loss</span>, <span class="n">dtype</span>=<span class="n">backend</span>.<span class="n">floatx</span>())

      <span class="n">loss</span>.<span class="n">_unconditional_loss</span> = <span class="nb">True</span>  <span class="c1"># pylint: disable=protected-access</span>

      <span class="k">return</span> <span class="n">loss</span>

    <span class="n">losses</span> = <span class="n">nest</span>.<span class="n">flatten</span>(<span class="n">losses</span>)

    <span class="n">callable_losses</span> = []

    <span class="n">eager_losses</span> = []

    <span class="n">symbolic_losses</span> = []

    <span class="k">for</span> <span class="n">loss</span> <span class="nb">in</span> <span class="n">losses:</span>

      <span class="k">if</span> <span class="n">callable</span>(<span class="n">loss</span>):

        <span class="n">callable_losses</span>.<span class="nb">append</span>(<span class="n">functools</span>.<span class="n">partial</span>(<span class="n">_tag_callable</span>, <span class="n">loss</span>))

        <span class="n">continue</span>

      <span class="k">if</span> <span class="n">loss</span> <span class="k">is</span> <span class="n">None:</span>

        <span class="n">continue</span>

      <span class="k">if</span> <span class="nb">not</span> <span class="n">tensor_util</span>.<span class="n">is_tensor</span>(<span class="n">loss</span>) <span class="o">and</span> <span class="nb">not</span> <span class="n">isinstance</span>(

          <span class="n">loss</span>, <span class="n">keras_tensor</span>.<span class="n">KerasTensor</span>):

        <span class="n">loss</span> = <span class="n">ops</span>.<span class="n">convert_to_tensor_v2_with_dispatch</span>(

            <span class="n">loss</span>, <span class="n">dtype</span>=<span class="n">backend</span>.<span class="n">floatx</span>())

      <span class="c1"># TF Functions should take the eager path.</span>

      <span class="k">if</span> ((<span class="n">tf_utils</span>.<span class="n">is_symbolic_tensor</span>(<span class="n">loss</span>) <span class="o">or</span>

           <span class="n">isinstance</span>(<span class="n">loss</span>, <span class="n">keras_tensor</span>.<span class="n">KerasTensor</span>)) <span class="o">and</span>

          <span class="nb">not</span> <span class="n">base_layer_utils</span>.<span class="n">is_in_tf_function</span>()):

        <span class="n">symbolic_losses</span>.<span class="nb">append</span>(<span class="n">loss</span>)

      <span class="n">elif</span> <span class="n">tensor_util</span>.<span class="n">is_tensor</span>(<span class="n">loss</span>):

        <span class="n">eager_losses</span>.<span class="nb">append</span>(<span class="n">loss</span>)

    <span class="nb">self</span>.<span class="n">_callable_losses</span>.<span class="n">extend</span>(<span class="n">callable_losses</span>)

    <span class="n">in_call_context</span> = <span class="n">base_layer_utils</span>.<span class="n">call_context</span>().<span class="n">in_call</span>

    <span class="k">if</span> <span class="n">eager_losses</span> <span class="o">and</span> <span class="nb">not</span> <span class="n">in_call_context:</span>

      <span class="n">raise</span> <span class="n">ValueError</span>(

          <span class="s">&#39;Expected a symbolic Tensors or a callable for the loss value. &#39;</span>

          <span class="s">&#39;Please wrap your loss computation in a zero argument `lambda`.&#39;</span>)

    <span class="nb">self</span>.<span class="n">_eager_losses</span>.<span class="n">extend</span>(<span class="n">eager_losses</span>)

    <span class="k">if</span> <span class="n">in_call_context</span> <span class="o">and</span> <span class="nb">not</span> <span class="n">keras_tensor</span>.<span class="n">keras_tensors_enabled</span>():

      <span class="k">for</span> <span class="n">symbolic_loss</span> <span class="nb">in</span> <span class="n">symbolic_losses:</span>

        <span class="nb">self</span>.<span class="n">_losses</span>.<span class="nb">append</span>(<span class="n">symbolic_loss</span>)

    <span class="n">else:</span>

      <span class="k">for</span> <span class="n">symbolic_loss</span> <span class="nb">in</span> <span class="n">symbolic_losses:</span>

        <span class="k">if</span> <span class="n">getattr</span>(<span class="nb">self</span>, <span class="s">&#39;_is_graph_network&#39;</span>, <span class="nb">False</span>):

          <span class="nb">self</span>.<span class="n">_graph_network_add_loss</span>(<span class="n">symbolic_loss</span>)

        <span class="n">else:</span>

          <span class="c1"># Possible a loss was added in a Layer&#39;s `build`.</span>

          <span class="nb">self</span>.<span class="n">_losses</span>.<span class="nb">append</span>(<span class="n">symbolic_loss</span>)
</code></pre></div>

</details>
<h5 id="add_metric">add_metric</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">add_metric</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>

<p>Adds metric tensor to the layer.</p>
<p>This method can be used inside the <code>call()</code> method of a subclassed layer
or model.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">MyMetricLayer</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">MyMetricLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;my_metric_layer&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">Mean</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;metric_1&#39;</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_metric</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;metric_2&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inputs</span>
</code></pre></div>

<p>This method can also be called directly on a Functional Model during
construction. In this case, any tensor passed to this Model must
be symbolic and be able to be traced back to the model's <code>Input</code>s. These
metrics become part of the model's topology and are tracked when you
save the model via <code>save()</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="n">inputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">math_ops</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;metric_1&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Note: Calling <code>add_metric()</code> with the result of a metric object on a
Functional Model, as shown in the example below, is not supported. This is
because we cannot trace the metric result tensor back to the model's inputs.</p>
<div class="codehilite"><pre><span></span><code><span class="n">inputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">Mean</span><span class="p">()(</span><span class="n">x</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;metric_1&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Args:
  value: Metric tensor.
  name: String metric name.
  **kwargs: Additional keyword arguments for backward compatibility.
    Accepted values:
    <code>aggregation</code> - When the <code>value</code> tensor provided is not the result of
    calling a <code>keras.Metric</code> instance, it will be aggregated by default
    using a <code>keras.Metric.Mean</code>.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">add_metric</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="k">value</span><span class="p">,</span> <span class="k">name</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Adds metric tensor to the layer.</span>

<span class="s2">    This method can be used inside the `call()` method of a subclassed layer</span>

<span class="s2">    or model.</span>

<span class="s2">    ```python</span>

<span class="s2">    class MyMetricLayer(tf.keras.layers.Layer):</span>

<span class="s2">      def __init__(self):</span>

<span class="s2">        super(MyMetricLayer, self).__init__(name=&#39;my_metric_layer&#39;)</span>

<span class="s2">        self.mean = tf.keras.metrics.Mean(name=&#39;metric_1&#39;)</span>

<span class="s2">      def call(self, inputs):</span>

<span class="s2">        self.add_metric(self.mean(x))</span>

<span class="s2">        self.add_metric(tf.reduce_sum(x), name=&#39;metric_2&#39;)</span>

<span class="s2">        return inputs</span>

<span class="s2">    ```</span>

<span class="s2">    This method can also be called directly on a Functional Model during</span>

<span class="s2">    construction. In this case, any tensor passed to this Model must</span>

<span class="s2">    be symbolic and be able to be traced back to the model&#39;s `Input`s. These</span>

<span class="s2">    metrics become part of the model&#39;s topology and are tracked when you</span>

<span class="s2">    save the model via `save()`.</span>

<span class="s2">    ```python</span>

<span class="s2">    inputs = tf.keras.Input(shape=(10,))</span>

<span class="s2">    x = tf.keras.layers.Dense(10)(inputs)</span>

<span class="s2">    outputs = tf.keras.layers.Dense(1)(x)</span>

<span class="s2">    model = tf.keras.Model(inputs, outputs)</span>

<span class="s2">    model.add_metric(math_ops.reduce_sum(x), name=&#39;metric_1&#39;)</span>

<span class="s2">    ```</span>

<span class="s2">    Note: Calling `add_metric()` with the result of a metric object on a</span>

<span class="s2">    Functional Model, as shown in the example below, is not supported. This is</span>

<span class="s2">    because we cannot trace the metric result tensor back to the model&#39;s inputs.</span>

<span class="s2">    ```python</span>

<span class="s2">    inputs = tf.keras.Input(shape=(10,))</span>

<span class="s2">    x = tf.keras.layers.Dense(10)(inputs)</span>

<span class="s2">    outputs = tf.keras.layers.Dense(1)(x)</span>

<span class="s2">    model = tf.keras.Model(inputs, outputs)</span>

<span class="s2">    model.add_metric(tf.keras.metrics.Mean()(x), name=&#39;metric_1&#39;)</span>

<span class="s2">    ```</span>

<span class="s2">    Args:</span>

<span class="s2">      value: Metric tensor.</span>

<span class="s2">      name: String metric name.</span>

<span class="s2">      **kwargs: Additional keyword arguments for backward compatibility.</span>

<span class="s2">        Accepted values:</span>

<span class="s2">        `aggregation` - When the `value` tensor provided is not the result of</span>

<span class="s2">        calling a `keras.Metric` instance, it will be aggregated by default</span>

<span class="s2">        using a `keras.Metric.Mean`.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="n">kwargs_keys</span> <span class="o">=</span> <span class="k">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">.</span><span class="k">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">kwargs_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">or</span>

        <span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">kwargs_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">and</span> <span class="n">kwargs_keys</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span> <span class="o">!=</span> <span class="s1">&#39;aggregation&#39;</span><span class="p">))</span><span class="o">:</span>

      <span class="n">raise</span> <span class="n">TypeError</span><span class="p">(</span><span class="s1">&#39;Unknown keyword arguments: &#39;</span><span class="p">,</span> <span class="n">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">.</span><span class="k">keys</span><span class="p">()))</span>

    <span class="n">from_metric_obj</span> <span class="o">=</span> <span class="n">hasattr</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="s1">&#39;_metric_obj&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keras_tensor</span><span class="p">.</span><span class="n">keras_tensors_enabled</span><span class="p">()</span><span class="o">:</span>

      <span class="n">is_symbolic</span> <span class="o">=</span> <span class="n">isinstance</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">keras_tensor</span><span class="p">.</span><span class="n">KerasTensor</span><span class="p">)</span>

    <span class="k">else</span><span class="o">:</span>

      <span class="n">is_symbolic</span> <span class="o">=</span> <span class="n">tf_utils</span><span class="p">.</span><span class="n">is_symbolic_tensor</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>

    <span class="n">in_call_context</span> <span class="o">=</span> <span class="n">base_layer_utils</span><span class="p">.</span><span class="n">call_context</span><span class="p">().</span><span class="n">in_call</span>

    <span class="k">if</span> <span class="k">name</span> <span class="k">is</span> <span class="k">None</span> <span class="k">and</span> <span class="k">not</span> <span class="n">from_metric_obj</span><span class="o">:</span>

      <span class="c1"># Eg. `self.add_metric(math_ops.reduce_sum(x))`</span>

      <span class="c1"># In eager mode, we use metric name to lookup a metric. Without a name,</span>

      <span class="c1"># a new Mean metric wrapper will be created on every model/layer call.</span>

      <span class="c1"># So, we raise an error when no name is provided.</span>

      <span class="c1"># We will do the same for symbolic mode for consistency although a name</span>

      <span class="c1"># will be generated if no name is provided.</span>

      <span class="c1"># We will not raise this error in the foll use case for the sake of</span>

      <span class="c1"># consistency as name in provided in the metric constructor.</span>

      <span class="c1"># mean = metrics.Mean(name=&#39;my_metric&#39;)</span>

      <span class="c1"># model.add_metric(mean(outputs))</span>

      <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="s1">&#39;Please provide a name for your metric like &#39;</span>

                       <span class="s1">&#39;`self.add_metric(tf.reduce_sum(inputs), &#39;</span>

                       <span class="s1">&#39;name=</span><span class="se">\&#39;</span><span class="s1">mean_activation</span><span class="se">\&#39;</span><span class="s1">)`&#39;</span><span class="p">)</span>

    <span class="n">elif</span> <span class="n">from_metric_obj</span><span class="o">:</span>

      <span class="k">name</span> <span class="o">=</span> <span class="k">value</span><span class="p">.</span><span class="n">_metric_obj</span><span class="p">.</span><span class="k">name</span>

    <span class="k">if</span> <span class="k">not</span> <span class="n">in_call_context</span> <span class="k">and</span> <span class="k">not</span> <span class="n">is_symbolic</span><span class="o">:</span>

      <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected a symbolic Tensor for the metric value, &#39;</span>

                       <span class="s1">&#39;received: &#39;</span> <span class="o">+</span> <span class="n">str</span><span class="p">(</span><span class="k">value</span><span class="p">))</span>

    <span class="c1"># If a metric was added in a Layer&#39;s `call` or `build`.</span>

    <span class="k">if</span> <span class="n">in_call_context</span> <span class="k">or</span> <span class="k">not</span> <span class="n">getattr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s1">&#39;_is_graph_network&#39;</span><span class="p">,</span> <span class="no">False</span><span class="p">)</span><span class="o">:</span>

      <span class="c1"># TF Function path should take the eager path.</span>

      <span class="c1"># If the given metric is available in `metrics` list we just update state</span>

      <span class="c1"># on it, otherwise we create a new metric instance and</span>

      <span class="c1"># add it to the `metrics` list.</span>

      <span class="n">metric_obj</span> <span class="o">=</span> <span class="n">getattr</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="s1">&#39;_metric_obj&#39;</span><span class="p">,</span> <span class="k">None</span><span class="p">)</span>

      <span class="c1"># Tensors that come from a Metric object already updated the Metric state.</span>

      <span class="n">should_update_state</span> <span class="o">=</span> <span class="k">not</span> <span class="n">metric_obj</span>

      <span class="k">name</span> <span class="o">=</span> <span class="n">metric_obj</span><span class="p">.</span><span class="k">name</span> <span class="k">if</span> <span class="n">metric_obj</span> <span class="k">else</span> <span class="k">name</span>

      <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="n">_metrics_lock</span><span class="o">:</span>

        <span class="k">match</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_get_existing_metric</span><span class="p">(</span><span class="k">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="k">match</span><span class="o">:</span>

          <span class="n">metric_obj</span> <span class="o">=</span> <span class="k">match</span>

        <span class="n">elif</span> <span class="n">metric_obj</span><span class="o">:</span>

          <span class="n">self</span><span class="p">.</span><span class="n">_metrics</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_obj</span><span class="p">)</span>

        <span class="k">else</span><span class="o">:</span>

          <span class="c1"># Build the metric object with the value&#39;s dtype if it defines one</span>

          <span class="n">metric_obj</span> <span class="o">=</span> <span class="n">metrics_mod</span><span class="p">.</span><span class="n">Mean</span><span class="p">(</span>

              <span class="k">name</span><span class="o">=</span><span class="k">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">getattr</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="k">None</span><span class="p">))</span>

          <span class="n">self</span><span class="p">.</span><span class="n">_metrics</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_obj</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">should_update_state</span><span class="o">:</span>

        <span class="n">metric_obj</span><span class="p">(</span><span class="k">value</span><span class="p">)</span>

    <span class="k">else</span><span class="o">:</span>

      <span class="k">if</span> <span class="n">from_metric_obj</span><span class="o">:</span>

        <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="s1">&#39;Using the result of calling a `Metric` object &#39;</span>

                         <span class="s1">&#39;when calling `add_metric` on a Functional &#39;</span>

                         <span class="s1">&#39;Model is not supported. Please pass the &#39;</span>

                         <span class="s1">&#39;Tensor to monitor directly.&#39;</span><span class="p">)</span>

      <span class="c1"># Insert layers into the Keras Graph Network.</span>

      <span class="n">aggregation</span> <span class="o">=</span> <span class="k">None</span> <span class="k">if</span> <span class="n">from_metric_obj</span> <span class="k">else</span> <span class="s1">&#39;mean&#39;</span>

      <span class="n">self</span><span class="p">.</span><span class="n">_graph_network_add_metric</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">aggregation</span><span class="p">,</span> <span class="k">name</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="add_update">add_update</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">add_update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">updates</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>

<p>Add update op(s), potentially dependent on layer inputs.</p>
<p>Weight updates (for instance, the updates of the moving mean and variance
in a BatchNormalization layer) may be dependent on the inputs passed
when calling a layer. Hence, when reusing the same layer on
different inputs <code>a</code> and <code>b</code>, some entries in <code>layer.updates</code> may be
dependent on <code>a</code> and some on <code>b</code>. This method automatically keeps track
of dependencies.</p>
<p>This call is ignored when eager execution is enabled (in that case, variable
updates are run on the fly and thus do not need to be tracked for later
execution).</p>
<p>Arguments:
  updates: Update op, or list/tuple of update ops, or zero-arg callable
    that returns an update op. A zero-arg callable should be passed in
    order to disable running the updates by setting <code>trainable=False</code>
    on this Layer, when executing in Eager mode.
  inputs: Deprecated, will be automatically inferred.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@doc_controls.do_not_doc_inheritable</span>

  <span class="n">def</span> <span class="n">add_update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="k">None</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Add update op(s), potentially dependent on layer inputs.</span>

<span class="s2">    Weight updates (for instance, the updates of the moving mean and variance</span>

<span class="s2">    in a BatchNormalization layer) may be dependent on the inputs passed</span>

<span class="s2">    when calling a layer. Hence, when reusing the same layer on</span>

<span class="s2">    different inputs `a` and `b`, some entries in `layer.updates` may be</span>

<span class="s2">    dependent on `a` and some on `b`. This method automatically keeps track</span>

<span class="s2">    of dependencies.</span>

<span class="s2">    This call is ignored when eager execution is enabled (in that case, variable</span>

<span class="s2">    updates are run on the fly and thus do not need to be tracked for later</span>

<span class="s2">    execution).</span>

<span class="s2">    Arguments:</span>

<span class="s2">      updates: Update op, or list/tuple of update ops, or zero-arg callable</span>

<span class="s2">        that returns an update op. A zero-arg callable should be passed in</span>

<span class="s2">        order to disable running the updates by setting `trainable=False`</span>

<span class="s2">        on this Layer, when executing in Eager mode.</span>

<span class="s2">      inputs: Deprecated, will be automatically inferred.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">inputs</span> <span class="k">is</span> <span class="k">not</span> <span class="k">None</span><span class="o">:</span>

      <span class="n">tf_logging</span><span class="p">.</span><span class="n">warning</span><span class="p">(</span>

          <span class="s1">&#39;`add_update` `inputs` kwarg has been deprecated. You no longer need &#39;</span>

          <span class="s1">&#39;to pass a value to `inputs` as it is being automatically inferred.&#39;</span><span class="p">)</span>

    <span class="n">call_context</span> <span class="o">=</span> <span class="n">base_layer_utils</span><span class="p">.</span><span class="n">call_context</span><span class="p">()</span>

    <span class="c1"># No need to run updates during Functional API construction.</span>

    <span class="k">if</span> <span class="n">call_context</span><span class="p">.</span><span class="n">in_keras_graph</span><span class="o">:</span>

      <span class="k">return</span>

    <span class="c1"># Callable updates are disabled by setting `trainable=False`.</span>

    <span class="k">if</span> <span class="k">not</span> <span class="n">call_context</span><span class="p">.</span><span class="n">frozen</span><span class="o">:</span>

      <span class="k">for</span> <span class="k">update</span> <span class="k">in</span> <span class="n">nest</span><span class="p">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">updates</span><span class="p">)</span><span class="o">:</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="k">update</span><span class="p">)</span><span class="o">:</span>

          <span class="k">update</span><span class="p">()</span>  <span class="c1"># pylint: disable=not-callable</span>
</code></pre></div>

</details>
<h5 id="add_variable">add_variable</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">add_variable</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>

<p>Deprecated, do NOT use! Alias for <code>add_weight</code>.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@doc_controls.do_not_doc_inheritable</span>

  <span class="n">def</span> <span class="n">add_variable</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Deprecated, do NOT use! Alias for `add_weight`.</span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">warnings</span><span class="p">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`layer.add_variable` is deprecated and &#39;</span>

                  <span class="s1">&#39;will be removed in a future version. &#39;</span>

                  <span class="s1">&#39;Please use `layer.add_weight` method instead.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">add_weight</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="add_weight">add_weight</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">add_weight</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">initializer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">regularizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">trainable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_resource</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">synchronization</span><span class="o">=&lt;</span><span class="n">VariableSynchronization</span><span class="o">.</span><span class="n">AUTO</span><span class="p">:</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">aggregation</span><span class="o">=&lt;</span><span class="n">VariableAggregation</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>

<p>Adds a new variable to the layer.</p>
<p>Arguments:
  name: Variable name.
  shape: Variable shape. Defaults to scalar if unspecified.
  dtype: The type of the variable. Defaults to <code>self.dtype</code>.
  initializer: Initializer instance (callable).
  regularizer: Regularizer instance (callable).
  trainable: Boolean, whether the variable should be part of the layer's
    "trainable_variables" (e.g. variables, biases)
    or "non_trainable_variables" (e.g. BatchNorm mean and variance).
    Note that <code>trainable</code> cannot be <code>True</code> if <code>synchronization</code>
    is set to <code>ON_READ</code>.
  constraint: Constraint instance (callable).
  use_resource: Whether to use <code>ResourceVariable</code>.
  synchronization: Indicates when a distributed a variable will be
    aggregated. Accepted values are constants defined in the class
    <code>tf.VariableSynchronization</code>. By default the synchronization is set to
    <code>AUTO</code> and the current <code>DistributionStrategy</code> chooses
    when to synchronize. If <code>synchronization</code> is set to <code>ON_READ</code>,
    <code>trainable</code> must not be set to <code>True</code>.
  aggregation: Indicates how a distributed variable will be aggregated.
    Accepted values are constants defined in the class
    <code>tf.VariableAggregation</code>.
  **kwargs: Additional keyword arguments. Accepted values are <code>getter</code>,
    <code>collections</code>, <code>experimental_autocast</code> and <code>caching_device</code>.</p>
<p>Returns:
  The variable created.</p>
<p>Raises:
  ValueError: When giving unsupported dtype and no initializer or when
    trainable has been set to True with synchronization set as <code>ON_READ</code>.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@doc_controls.for_subclass_implementers</span>

  <span class="n">def</span> <span class="n">add_weight</span><span class="p">(</span><span class="n">self</span><span class="p">,</span>

                 <span class="k">name</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">shape</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">dtype</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">initializer</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">regularizer</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">trainable</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="k">constraint</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">use_resource</span><span class="o">=</span><span class="k">None</span><span class="p">,</span>

                 <span class="n">synchronization</span><span class="o">=</span><span class="n">tf_variables</span><span class="p">.</span><span class="n">VariableSynchronization</span><span class="p">.</span><span class="n">AUTO</span><span class="p">,</span>

                 <span class="n">aggregation</span><span class="o">=</span><span class="n">tf_variables</span><span class="p">.</span><span class="n">VariableAggregation</span><span class="p">.</span><span class="k">NONE</span><span class="p">,</span>

                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Adds a new variable to the layer.</span>

<span class="s2">    Arguments:</span>

<span class="s2">      name: Variable name.</span>

<span class="s2">      shape: Variable shape. Defaults to scalar if unspecified.</span>

<span class="s2">      dtype: The type of the variable. Defaults to `self.dtype`.</span>

<span class="s2">      initializer: Initializer instance (callable).</span>

<span class="s2">      regularizer: Regularizer instance (callable).</span>

<span class="s2">      trainable: Boolean, whether the variable should be part of the layer&#39;s</span>

<span class="s2">        &quot;</span><span class="n">trainable_variables</span><span class="s2">&quot; (e.g. variables, biases)</span>

<span class="s2">        or &quot;</span><span class="n">non_trainable_variables</span><span class="s2">&quot; (e.g. BatchNorm mean and variance).</span>

<span class="s2">        Note that `trainable` cannot be `True` if `synchronization`</span>

<span class="s2">        is set to `ON_READ`.</span>

<span class="s2">      constraint: Constraint instance (callable).</span>

<span class="s2">      use_resource: Whether to use `ResourceVariable`.</span>

<span class="s2">      synchronization: Indicates when a distributed a variable will be</span>

<span class="s2">        aggregated. Accepted values are constants defined in the class</span>

<span class="s2">        `tf.VariableSynchronization`. By default the synchronization is set to</span>

<span class="s2">        `AUTO` and the current `DistributionStrategy` chooses</span>

<span class="s2">        when to synchronize. If `synchronization` is set to `ON_READ`,</span>

<span class="s2">        `trainable` must not be set to `True`.</span>

<span class="s2">      aggregation: Indicates how a distributed variable will be aggregated.</span>

<span class="s2">        Accepted values are constants defined in the class</span>

<span class="s2">        `tf.VariableAggregation`.</span>

<span class="s2">      **kwargs: Additional keyword arguments. Accepted values are `getter`,</span>

<span class="s2">        `collections`, `experimental_autocast` and `caching_device`.</span>

<span class="s2">    Returns:</span>

<span class="s2">      The variable created.</span>

<span class="s2">    Raises:</span>

<span class="s2">      ValueError: When giving unsupported dtype and no initializer or when</span>

<span class="s2">        trainable has been set to True with synchronization set as `ON_READ`.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">shape</span> <span class="k">is</span> <span class="k">None</span><span class="o">:</span>

      <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;partitioner&#39;</span><span class="p">,</span> <span class="k">None</span><span class="p">)</span>  <span class="c1"># Ignored.</span>

    <span class="c1"># Validate optional keyword arguments.</span>

    <span class="k">for</span> <span class="n">kwarg</span> <span class="k">in</span> <span class="n">kwargs</span><span class="o">:</span>

      <span class="k">if</span> <span class="n">kwarg</span> <span class="k">not</span> <span class="k">in</span> <span class="err">[</span><span class="s1">&#39;collections&#39;</span><span class="p">,</span> <span class="s1">&#39;experimental_autocast&#39;</span><span class="p">,</span>

                       <span class="s1">&#39;caching_device&#39;</span><span class="p">,</span> <span class="s1">&#39;getter&#39;</span><span class="err">]</span><span class="o">:</span>

        <span class="n">raise</span> <span class="n">TypeError</span><span class="p">(</span><span class="s1">&#39;Unknown keyword argument:&#39;</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">)</span>

    <span class="n">collections_arg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;collections&#39;</span><span class="p">,</span> <span class="k">None</span><span class="p">)</span>

    <span class="c1"># &#39;experimental_autocast&#39; can be set to False by the caller to indicate an</span>

    <span class="c1"># AutoCastVariable should never be created.</span>

    <span class="n">autocast</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;experimental_autocast&#39;</span><span class="p">,</span> <span class="no">True</span><span class="p">)</span>

    <span class="c1"># See the docstring for tf.Variable about the details for caching_device.</span>

    <span class="n">caching_device</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;caching_device&#39;</span><span class="p">,</span> <span class="k">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="k">is</span> <span class="k">None</span><span class="o">:</span>

      <span class="n">dtype</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">dtype</span> <span class="k">or</span> <span class="n">backend</span><span class="p">.</span><span class="n">floatx</span><span class="p">()</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="p">.</span><span class="n">as_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">_dtype_policy</span><span class="p">.</span><span class="n">variable_dtype</span> <span class="k">is</span> <span class="k">None</span><span class="o">:</span>

      <span class="c1"># The policy is &quot;_infer&quot;, so we infer the policy from the variable dtype.</span>

      <span class="n">self</span><span class="p">.</span><span class="n">_set_dtype_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">.</span><span class="n">Policy</span><span class="p">(</span><span class="n">dtype</span><span class="p">.</span><span class="n">base_dtype</span><span class="p">.</span><span class="k">name</span><span class="p">))</span>

    <span class="n">initializer</span> <span class="o">=</span> <span class="n">initializers</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">initializer</span><span class="p">)</span>

    <span class="n">regularizer</span> <span class="o">=</span> <span class="n">regularizers</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">regularizer</span><span class="p">)</span>

    <span class="k">constraint</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="k">constraint</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">synchronization</span> <span class="o">==</span> <span class="n">tf_variables</span><span class="p">.</span><span class="n">VariableSynchronization</span><span class="p">.</span><span class="n">ON_READ</span><span class="o">:</span>

      <span class="k">if</span> <span class="n">trainable</span><span class="o">:</span>

        <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span>

            <span class="s1">&#39;Synchronization value can be set to &#39;</span>

            <span class="s1">&#39;VariableSynchronization.ON_READ only for non-trainable variables. &#39;</span>

            <span class="s1">&#39;You have specified trainable=True and &#39;</span>

            <span class="s1">&#39;synchronization=VariableSynchronization.ON_READ.&#39;</span><span class="p">)</span>

      <span class="k">else</span><span class="o">:</span>

        <span class="c1"># Set trainable to be false when variable is to be synced on read.</span>

        <span class="n">trainable</span> <span class="o">=</span> <span class="no">False</span>

    <span class="n">elif</span> <span class="n">trainable</span> <span class="k">is</span> <span class="k">None</span><span class="o">:</span>

      <span class="n">trainable</span> <span class="o">=</span> <span class="no">True</span>

    <span class="c1"># Initialize variable when no initializer provided</span>

    <span class="k">if</span> <span class="n">initializer</span> <span class="k">is</span> <span class="k">None</span><span class="o">:</span>

      <span class="c1"># If dtype is DT_FLOAT, provide a uniform unit scaling initializer</span>

      <span class="k">if</span> <span class="n">dtype</span><span class="p">.</span><span class="n">is_floating</span><span class="o">:</span>

        <span class="n">initializer</span> <span class="o">=</span> <span class="n">initializers</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s1">&#39;glorot_uniform&#39;</span><span class="p">)</span>

      <span class="c1"># If dtype is DT_INT/DT_UINT, provide a default value `zero`</span>

      <span class="c1"># If dtype is DT_BOOL, provide a default value `FALSE`</span>

      <span class="n">elif</span> <span class="n">dtype</span><span class="p">.</span><span class="n">is_integer</span> <span class="k">or</span> <span class="n">dtype</span><span class="p">.</span><span class="n">is_unsigned</span> <span class="k">or</span> <span class="n">dtype</span><span class="p">.</span><span class="n">is_bool</span><span class="o">:</span>

        <span class="n">initializer</span> <span class="o">=</span> <span class="n">initializers</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>

      <span class="c1"># NOTES:Do we need to support for handling DT_STRING and DT_COMPLEX here?</span>

      <span class="k">else</span><span class="o">:</span>

        <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="s1">&#39;An initializer for variable %s of type %s is required&#39;</span>

                         <span class="s1">&#39; for layer %s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="k">name</span><span class="p">,</span> <span class="n">dtype</span><span class="p">.</span><span class="n">base_dtype</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="k">name</span><span class="p">))</span>

    <span class="n">getter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;getter&#39;</span><span class="p">,</span> <span class="n">base_layer_utils</span><span class="p">.</span><span class="n">make_variable</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">autocast</span> <span class="k">and</span>

        <span class="n">self</span><span class="p">.</span><span class="n">_dtype_policy</span><span class="p">.</span><span class="n">compute_dtype</span> <span class="o">!=</span> <span class="n">self</span><span class="p">.</span><span class="n">_dtype_policy</span><span class="p">.</span><span class="n">variable_dtype</span>

        <span class="k">and</span> <span class="n">dtype</span><span class="p">.</span><span class="n">is_floating</span><span class="p">)</span><span class="o">:</span>

      <span class="n">old_getter</span> <span class="o">=</span> <span class="n">getter</span>

      <span class="c1"># Wrap variable constructor to return an AutoCastVariable.</span>

      <span class="n">def</span> <span class="n">getter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">:</span>  <span class="c1"># pylint: disable=function-redefined</span>

        <span class="n">variable</span> <span class="o">=</span> <span class="n">old_getter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">autocast_variable</span><span class="p">.</span><span class="n">create_autocast_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

      <span class="c1"># Also the caching_device does not work with the mixed precision API,</span>

      <span class="c1"># disable it if it is specified.</span>

      <span class="c1"># TODO(b/142020079): Reenable it once the bug is fixed.</span>

      <span class="k">if</span> <span class="n">caching_device</span> <span class="k">is</span> <span class="k">not</span> <span class="k">None</span><span class="o">:</span>

        <span class="n">tf_logging</span><span class="p">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`caching_device` does not work with mixed precision &#39;</span>

                        <span class="s1">&#39;API. Ignoring user specified `caching_device`.&#39;</span><span class="p">)</span>

        <span class="n">caching_device</span> <span class="o">=</span> <span class="k">None</span>

    <span class="n">variable</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_add_variable_with_custom_getter</span><span class="p">(</span>

        <span class="k">name</span><span class="o">=</span><span class="k">name</span><span class="p">,</span>

        <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>

        <span class="c1"># TODO(allenl): a `make_variable` equivalent should be added as a</span>

        <span class="c1"># `Trackable` method.</span>

        <span class="n">getter</span><span class="o">=</span><span class="n">getter</span><span class="p">,</span>

        <span class="c1"># Manage errors in Layer rather than Trackable.</span>

        <span class="n">overwrite</span><span class="o">=</span><span class="no">True</span><span class="p">,</span>

        <span class="n">initializer</span><span class="o">=</span><span class="n">initializer</span><span class="p">,</span>

        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>

        <span class="k">constraint</span><span class="o">=</span><span class="k">constraint</span><span class="p">,</span>

        <span class="n">trainable</span><span class="o">=</span><span class="n">trainable</span><span class="p">,</span>

        <span class="n">use_resource</span><span class="o">=</span><span class="n">use_resource</span><span class="p">,</span>

        <span class="n">collections</span><span class="o">=</span><span class="n">collections_arg</span><span class="p">,</span>

        <span class="n">synchronization</span><span class="o">=</span><span class="n">synchronization</span><span class="p">,</span>

        <span class="n">aggregation</span><span class="o">=</span><span class="n">aggregation</span><span class="p">,</span>

        <span class="n">caching_device</span><span class="o">=</span><span class="n">caching_device</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">regularizer</span> <span class="k">is</span> <span class="k">not</span> <span class="k">None</span><span class="o">:</span>

      <span class="c1"># TODO(fchollet): in the future, this should be handled at the</span>

      <span class="c1"># level of variable creation, and weight regularization losses</span>

      <span class="c1"># should be variable attributes.</span>

      <span class="n">name_in_scope</span> <span class="o">=</span> <span class="n">variable</span><span class="p">.</span><span class="k">name</span><span class="err">[</span><span class="o">:</span><span class="n">variable</span><span class="p">.</span><span class="k">name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span><span class="err">]</span>

      <span class="n">self</span><span class="p">.</span><span class="n">_handle_weight_regularization</span><span class="p">(</span><span class="n">name_in_scope</span><span class="p">,</span>

                                         <span class="n">variable</span><span class="p">,</span>

                                         <span class="n">regularizer</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">base_layer_utils</span><span class="p">.</span><span class="n">is_split_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="o">:</span>

      <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="n">variable</span><span class="o">:</span>

        <span class="n">backend</span><span class="p">.</span><span class="n">track_variable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trainable</span><span class="o">:</span>

          <span class="n">self</span><span class="p">.</span><span class="n">_trainable_weights</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">else</span><span class="o">:</span>

          <span class="n">self</span><span class="p">.</span><span class="n">_non_trainable_weights</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">else</span><span class="o">:</span>

      <span class="n">backend</span><span class="p">.</span><span class="n">track_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">trainable</span><span class="o">:</span>

        <span class="n">self</span><span class="p">.</span><span class="n">_trainable_weights</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

      <span class="k">else</span><span class="o">:</span>

        <span class="n">self</span><span class="p">.</span><span class="n">_non_trainable_weights</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">variable</span>
</code></pre></div>

</details>
<h5 id="apply">apply</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">apply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>

<p>Deprecated, do NOT use!</p>
<p>This is an alias of <code>self.__call__</code>.</p>
<p>Arguments:
  inputs: Input tensor(s).
  <em>args: additional positional arguments to be passed to <code>self.call</code>.
  </em>*kwargs: additional keyword arguments to be passed to <code>self.call</code>.</p>
<p>Returns:
  Output tensor(s).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">apply</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Deprecated, do NOT use!</span>

<span class="ss">    This is an alias of `self.__call__`.</span>

<span class="ss">    Arguments:</span>

<span class="ss">      inputs: Input tensor(s).</span>

<span class="ss">      *args: additional positional arguments to be passed to `self.call`.</span>

<span class="ss">      **kwargs: additional keyword arguments to be passed to `self.call`.</span>

<span class="ss">    Returns:</span>

<span class="ss">      Output tensor(s).</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">warnings</span><span class="p">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`layer.apply` is deprecated and &#39;</span><span class="w"></span>

<span class="w">                  </span><span class="s1">&#39;will be removed in a future version. &#39;</span><span class="w"></span>

<span class="w">                  </span><span class="s1">&#39;Please use `layer.__call__` method instead.&#39;</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">__call__</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="build">build</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">build</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">input_shape</span>
<span class="p">)</span>
</code></pre></div>

<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="n">build</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">)</span><span class="o">:</span>

        <span class="n">self</span><span class="p">.</span><span class="n">rpn_conv2d</span> <span class="o">=</span> <span class="n">KL</span><span class="p">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mh">512</span><span class="p">,</span> <span class="p">(</span><span class="mh">3</span><span class="p">,</span> <span class="mh">3</span><span class="p">),</span>

                                    <span class="n">padding</span><span class="o">=</span><span class="p">&#39;</span><span class="n">same</span><span class="p">&#39;,</span>

                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">_kernel_initializer_classification_head</span><span class="p">,</span>

                                    <span class="n">kernel_regularizer</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">_kernel_regularizer</span><span class="p">)</span>

        <span class="n">super</span><span class="p">().</span><span class="n">build</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="build_detection_head">build_detection_head</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">build_detection_head</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span>
<span class="p">)</span>
</code></pre></div>

<p>Build a detection head composed </p>
<p>Arguments:</p>
<ul>
<li><em>inputs</em>: A tensor of shape [batch_size, H, W, C]</li>
</ul>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="n">build_detection_head</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>

        <span class="ss">&quot;&quot;&quot; Build a detection head composed</span>

<span class="ss">        Arguments:</span>

<span class="ss">        - *inputs*: A tensor of shape [batch_size, H, W, C]</span>

<span class="ss">        &quot;&quot;&quot;</span>

        <span class="n">classification_head</span> <span class="o">=</span> <span class="k">self</span><span class="p">.</span><span class="n">_conv_classification_head</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">box_prediction_head</span> <span class="o">=</span> <span class="k">self</span><span class="p">.</span><span class="n">_conv_box_prediction_head</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">classification_head</span><span class="p">,</span> <span class="n">box_prediction_head</span>
</code></pre></div>

</details>
<h5 id="build_rpn_head">build_rpn_head</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">build_rpn_head</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span>
<span class="p">)</span>
</code></pre></div>

<p>Predictions for the classification and the regression</p>
<p>Arguments:</p>
<ul>
<li><em>inputs</em>: A tensor of  shape [batch_size, width, height, channel]</li>
</ul>
<p>Returns:</p>
<p>A tuple of tensors of shape ([batch_size, num_anchors, 2], [batch_size, num_anchors, 4])</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="n">build_rpn_head</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span><span class="o">:</span>

        <span class="s">&quot;&quot;&quot;Predictions for the classification and the regression</span>

        <span class="nl">Arguments:</span>

        <span class="o">-</span> <span class="o">*</span><span class="n">inputs</span><span class="o">*:</span> <span class="n">A</span> <span class="n">tensor</span> <span class="n">of</span>  <span class="n">shape</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">channel</span><span class="p">]</span>

        <span class="nl">Returns:</span>

        <span class="n">A</span> <span class="n">tuple</span> <span class="n">of</span> <span class="n">tensors</span> <span class="n">of</span> <span class="n">shape</span> <span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span><span class="p">,</span> <span class="mh">2</span><span class="p">],</span> <span class="p">[</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_anchors</span><span class="p">,</span> <span class="mh">4</span><span class="p">])</span>

        <span class="s">&quot;&quot;&quot;</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="n">inputs</span><span class="p">)[</span><span class="mh">0</span><span class="p">]</span>

        <span class="n">rpn_conv2d</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rpn_conv2d</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">classification_head</span><span class="p">,</span> <span class="n">localization_head</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">build_detection_head</span><span class="p">(</span><span class="n">rpn_conv2d</span><span class="p">)</span>

        <span class="n">classification_head</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">classification_head</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mh">1</span><span class="p">,</span> <span class="mh">2</span><span class="p">))</span>

        <span class="n">localization_head</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">localization_head</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mh">1</span><span class="p">,</span> <span class="mh">4</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">classification_head</span><span class="p">,</span> <span class="n">localization_head</span>
</code></pre></div>

</details>
<h5 id="build_segmentation_head">build_segmentation_head</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">build_segmentation_head</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span>
<span class="p">)</span>
</code></pre></div>

<p>Build the detection head</p>
<p>Arguments:</p>
<ul>
<li><em>inputs</em>: A tensor of  shape [N, H, W, C]
        num_convs:</li>
</ul>
<p>Returns:</p>
<p>A tensor and shape [N, H<em>2, W</em>2, num_classes - 1]</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="n">build_segmentation_head</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>

        <span class="ss">&quot;&quot;&quot;Build the detection head</span>

<span class="ss">        Arguments:</span>

<span class="ss">        - *inputs*: A tensor of  shape [N, H, W, C]</span>

<span class="ss">                num_convs:</span>

<span class="ss">        Returns:</span>

<span class="ss">        A tensor and shape [N, H*2, W*2, num_classes - 1]</span>

<span class="ss">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="k">for</span> <span class="n">layer</span> <span class="k">in</span> <span class="k">self</span><span class="p">.</span><span class="n">_segmentation_layers</span><span class="p">:</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>
</code></pre></div>

</details>
<h5 id="call">call</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div>

<p>Create the computation graph for the rpn inference</p>
<p>Argument:</p>
<p><em>inputs</em>: A List of tensors the output of the pyramid</p>
<p>Returns:</p>
<ul>
<li><em>localization_pred</em>: A list of logits 3-D tensor of shape [batch_size, num_anchors, 4]</li>
<li><em>classification_pred</em>: A lost of logits 3-D tensor of shape [batch_size, num_anchors, 2]</li>
<li><em>anchors</em>: A list of tensors of shape [batch_size, num_anchors, (y_min, x_min, y_max, x_max)]</li>
</ul>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="k">call</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">tf</span><span class="p">.</span><span class="n">Tensor</span><span class="p">]):</span>

        <span class="ss">&quot;&quot;&quot;Create the computation graph for the rpn inference</span>

<span class="ss">        Argument:</span>

<span class="ss">        *inputs*: A List of tensors the output of the pyramid</span>

<span class="ss">        Returns:</span>

<span class="ss">        - *localization_pred*: A list of logits 3-D tensor of shape [batch_size, num_anchors, 4]</span>

<span class="ss">        - *classification_pred*: A lost of logits 3-D tensor of shape [batch_size, num_anchors, 2]</span>

<span class="ss">        - *anchors*: A list of tensors of shape [batch_size, num_anchors, (y_min, x_min, y_max, x_max)]</span>

<span class="ss">        &quot;&quot;&quot;</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="p">[</span><span class="n">anchors</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span> <span class="k">for</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">anchors</span> <span class="k">in</span> <span class="n">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="k">self</span><span class="p">.</span><span class="n">_anchors</span><span class="p">)]</span>

        <span class="n">rpn_predictions</span> <span class="o">=</span> <span class="p">[</span><span class="k">self</span><span class="p">.</span><span class="n">build_rpn_head</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span> <span class="k">for</span> <span class="n">tensor</span> <span class="k">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="n">localization_pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">prediction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">prediction</span> <span class="k">in</span> <span class="n">rpn_predictions</span><span class="p">]</span>

        <span class="n">classification_pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">prediction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">prediction</span> <span class="k">in</span> <span class="n">rpn_predictions</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">localization_pred</span><span class="p">,</span> <span class="n">classification_pred</span><span class="p">,</span> <span class="n">anchors</span>
</code></pre></div>

</details>
<h5 id="compute_loss">compute_loss</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_loss</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">localization_pred</span><span class="p">,</span>
    <span class="n">classification_pred</span><span class="p">,</span>
    <span class="n">anchors</span><span class="p">,</span>
    <span class="n">ground_truths</span>
<span class="p">)</span>
</code></pre></div>

<p>Compute the loss</p>
<p>Arguments:</p>
<ul>
<li><em>localization_pred</em>: A list of tensors of shape [batch_size, num_anchors, 4].</li>
<li><em>classification_pred</em>: A list of tensors of shape [batch_size, num_anchors, 2]</li>
<li><em>anchors</em>: A list of tensors of shape [num_anchors, (y_min, x_min, y_max, x_max)]</li>
<li><em>ground_truths</em>: A dict with BoxField as key and a tensor as value.</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">ground_truths</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
    <span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">:</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
    <span class="n">BoxField</span><span class="o">.</span><span class="n">WEIGHTS</span><span class="p">:</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
    <span class="n">BoxField</span><span class="o">.</span><span class="n">NUM_BOXES</span><span class="p">:</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>where <code>NUM_BOXES</code> allows to remove the padding created by tf.Data.</p>
<p>Returns:</p>
<ul>
<li><em>classification_loss</em>: A scalar in tf.float32</li>
<li><em>localization_loss</em>: A scalar in tf.float32</li>
</ul>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="n">compute_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localization_pred</span><span class="p">,</span> <span class="n">classification_pred</span><span class="p">,</span> <span class="n">anchors</span><span class="p">,</span> <span class="n">ground_truths</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Compute the loss</span>

<span class="sd">        Arguments:</span>

<span class="sd">        - *localization_pred*: A list of tensors of shape [batch_size, num_anchors, 4].</span>

<span class="sd">        - *classification_pred*: A list of tensors of shape [batch_size, num_anchors, 2]</span>

<span class="sd">        - *anchors*: A list of tensors of shape [num_anchors, (y_min, x_min, y_max, x_max)]</span>

<span class="sd">        - *ground_truths*: A dict with BoxField as key and a tensor as value.</span>

<span class="sd">        ```python</span>

<span class="sd">        ground_truths = {</span>

<span class="sd">            BoxField.BOXES:</span>

<span class="sd">                tf.constant([[[0, 0, 1, 1], [0, 0, 2, 2]], [[0, 0, 3, 3], [0, 0, 0, 0]]], tf.float32),</span>

<span class="sd">            BoxField.LABELS:</span>

<span class="sd">                tf.constant([[1, 0], [1, 0]], tf.float32),</span>

<span class="sd">            BoxField.WEIGHTS:</span>

<span class="sd">                tf.constant([[1, 0], [1, 1]], tf.float32),</span>

<span class="sd">            BoxField.NUM_BOXES:</span>

<span class="sd">                tf.constant([[2], [1]], tf.int32)</span>

<span class="sd">        }</span>

<span class="sd">        ```</span>

<span class="sd">        where `NUM_BOXES` allows to remove the padding created by tf.Data.</span>

<span class="sd">        Returns:</span>

<span class="sd">        - *classification_loss*: A scalar in tf.float32</span>

<span class="sd">        - *localization_loss*: A scalar in tf.float32</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">localization_pred</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">localization_pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">classification_pred</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">classification_pred</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">ground_truths</span> <span class="o">=</span> <span class="p">{</span>

            <span class="c1"># We add one because the background is not counted in ground_truths[BoxField.LABELS]</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">],</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">WEIGHTS</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">WEIGHTS</span><span class="p">],</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">NUM_BOXES</span><span class="p">:</span>

                <span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">NUM_BOXES</span><span class="p">]</span>

        <span class="p">}</span>

        <span class="c1"># anchors are deterministic duplicate them to create a batch</span>

        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">anchors</span><span class="p">[</span><span class="n">None</span><span class="p">],</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ground_truths</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">y_true</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_assigner</span><span class="o">.</span><span class="n">assign</span><span class="p">({</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span> <span class="n">anchors</span><span class="p">},</span> <span class="n">ground_truths</span><span class="p">)</span>

        <span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1">## Compute metrics</span>

        <span class="n">recall</span> <span class="o">=</span> <span class="n">compute_rpn_metrics</span><span class="p">(</span><span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">],</span> <span class="n">classification_pred</span><span class="p">,</span>

                                     <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">recall</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rpn_recall&#39;</span><span class="p">,</span> <span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>

        <span class="c1"># All the boxes which are not -1 can be sampled</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">y_true</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">batch_sample_balanced_positive_negative</span><span class="p">(</span>

            <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">],</span>

            <span class="n">SAMPLING_SIZE</span><span class="p">,</span>

            <span class="n">labels</span><span class="p">,</span>

            <span class="n">positive_fraction</span><span class="o">=</span><span class="n">SAMPLING_POSITIVE_RATIO</span><span class="p">,</span>

            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_dtype</span><span class="p">)</span>

        <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">]</span>

        <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_idx</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">]</span>

        <span class="n">y_pred</span> <span class="o">=</span> <span class="p">{</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">LABELS</span><span class="p">:</span> <span class="n">classification_pred</span><span class="p">,</span>

            <span class="n">BoxField</span><span class="o">.</span><span class="n">BOXES</span><span class="p">:</span> <span class="n">localization_pred</span>

        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_losses</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="compute_losses">compute_losses</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_losses</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">y_true</span><span class="p">:</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="n">y_pred</span><span class="p">:</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="n">weights</span><span class="p">:</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">tensorflow</span><span class="o">.</span><span class="n">python</span><span class="o">.</span><span class="n">framework</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span>
</code></pre></div>

<p>Compute the losses of the object detection head.
Each dictionary is composed of the same key (classification, localization, segmentation)</p>
<p>Arguments:</p>
<ul>
<li><em>y_pred</em>: A dict of tensors of shape [N, nb_boxes, num_output].</li>
<li><em>y_true</em>: A dict of tensors of shape [N, nb_boxes, num_output].</li>
<li><em>weights</em>: A dict of tensors ofshape [N, nb_boxes, num_output].
        This tensor is composed of one hot vectors.</li>
</ul>
<p>Returns:</p>
<p>A dict of different losses</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">compute_losses</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="nl">y_true</span><span class="p">:</span><span class="w"> </span><span class="n">Dict</span><span class="o">[</span><span class="n">str, tf.Tensor</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="nl">y_pred</span><span class="p">:</span><span class="w"> </span><span class="n">Dict</span><span class="o">[</span><span class="n">str, tf.Tensor</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">                       </span><span class="nl">weights</span><span class="p">:</span><span class="w"> </span><span class="n">Dict</span><span class="o">[</span><span class="n">str, tf.Tensor</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nl">dict</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="ss">&quot;&quot;&quot;Compute the losses of the object detection head.</span>

<span class="ss">        Each dictionary is composed of the same key (classification, localization, segmentation)</span>

<span class="ss">        Arguments:</span>

<span class="ss">        - *y_pred*: A dict of tensors of shape [N, nb_boxes, num_output].</span>

<span class="ss">        - *y_true*: A dict of tensors of shape [N, nb_boxes, num_output].</span>

<span class="ss">        - *weights*: A dict of tensors ofshape [N, nb_boxes, num_output].</span>

<span class="ss">                This tensor is composed of one hot vectors.</span>

<span class="ss">        Returns:</span>

<span class="ss">        A dict of different losses</span>

<span class="ss">        &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">        </span><span class="n">def</span><span class="w"> </span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span><span class="w"> </span><span class="n">loss_weight</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">            </span><span class="n">losses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loss</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="n">y_true</span><span class="o">[</span><span class="n">target</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span><span class="w"></span>

<span class="w">                          </span><span class="n">tf</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="n">y_pred</span><span class="o">[</span><span class="n">target</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span><span class="w"></span>

<span class="w">                          </span><span class="n">sample_weight</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="n">weights</span><span class="o">[</span><span class="n">target</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">))</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">loss_weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">losses</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">normalizer</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">normalizer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">weights</span><span class="o">[</span><span class="n">BoxField.LABELS</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">normalizer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="nf">cast</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span><span class="w"> </span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">classification_loss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_classification_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                                            </span><span class="n">self</span><span class="p">.</span><span class="n">_classification_loss_weight</span><span class="p">,</span><span class="w"> </span><span class="n">BoxField</span><span class="p">.</span><span class="n">LABELS</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">classification_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                        </span><span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;{self.name}_classification_loss&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                        </span><span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">localization_loss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_localization_loss</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_localization_loss_weight</span><span class="p">,</span><span class="w"></span>

<span class="w">                                          </span><span class="n">BoxField</span><span class="p">.</span><span class="n">BOXES</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">localization_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                        </span><span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;{self.name}_localization_loss&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                        </span><span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="n">self</span><span class="p">.</span><span class="n">add_loss</span><span class="p">(</span><span class="o">[</span><span class="n">classification_loss, localization_loss</span><span class="o">]</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nl">_use_mask</span><span class="p">:</span><span class="w"></span>

<span class="w">            </span><span class="n">segmentation_loss</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_compute_loss</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_segmentation_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                                              </span><span class="n">self</span><span class="p">.</span><span class="n">_segmentation_loss_weight</span><span class="p">,</span><span class="w"> </span><span class="n">BoxField</span><span class="p">.</span><span class="n">MASKS</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="n">self</span><span class="p">.</span><span class="n">add_metric</span><span class="p">(</span><span class="n">segmentation_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                            </span><span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;{self.name}_segmentation_loss&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                            </span><span class="n">aggregation</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="n">self</span><span class="p">.</span><span class="n">add_loss</span><span class="p">(</span><span class="n">segmentation_loss</span><span class="p">)</span><span class="w"></span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="err">{</span><span class="w"></span>

<span class="w">                </span><span class="n">BoxField</span><span class="p">.</span><span class="nl">LABELS</span><span class="p">:</span><span class="w"> </span><span class="n">classification_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                </span><span class="n">BoxField</span><span class="p">.</span><span class="nl">BOXES</span><span class="p">:</span><span class="w"> </span><span class="n">localization_loss</span><span class="p">,</span><span class="w"></span>

<span class="w">                </span><span class="n">BoxField</span><span class="p">.</span><span class="nl">MASKS</span><span class="p">:</span><span class="w"> </span><span class="n">segmentation_loss</span><span class="w"></span>

<span class="w">            </span><span class="err">}</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="err">{</span><span class="n">BoxField</span><span class="p">.</span><span class="nl">LABELS</span><span class="p">:</span><span class="w"> </span><span class="n">classification_loss</span><span class="p">,</span><span class="w"> </span><span class="n">BoxField</span><span class="p">.</span><span class="nl">BOXES</span><span class="p">:</span><span class="w"> </span><span class="n">localization_loss</span><span class="err">}</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="compute_mask">compute_mask</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_mask</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">,</span>
    <span class="n">mask</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>

<p>Computes an output mask tensor.</p>
<p>Arguments:
    inputs: Tensor or list of tensors.
    mask: Tensor or list of tensors.</p>
<p>Returns:
    None or a tensor (or list of tensors,
        one per output tensor of the layer).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@generic_utils</span><span class="p">.</span><span class="k">default</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">compute_mask</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="o">=</span><span class="k">None</span><span class="p">)</span><span class="err">:</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="nl">pylint</span><span class="p">:</span><span class="w"> </span><span class="n">disable</span><span class="o">=</span><span class="n">unused</span><span class="o">-</span><span class="n">argument</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Computes an output mask tensor.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        inputs: Tensor or list of tensors.</span>

<span class="ss">        mask: Tensor or list of tensors.</span>

<span class="ss">    Returns:</span>

<span class="ss">        None or a tensor (or list of tensors,</span>

<span class="ss">            one per output tensor of the layer).</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nl">_supports_masking</span><span class="p">:</span><span class="w"></span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="ow">any</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="k">None</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">nest</span><span class="p">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span><span class="err">:</span><span class="w"></span>

<span class="w">        </span><span class="n">raise</span><span class="w"> </span><span class="n">TypeError</span><span class="p">(</span><span class="s1">&#39;Layer &#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39; does not support masking, &#39;</span><span class="w"></span>

<span class="w">                        </span><span class="s1">&#39;but was passed an input_mask: &#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">str</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span><span class="w"></span>

<span class="w">      </span><span class="err">#</span><span class="w"> </span><span class="n">masking</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">explicitly</span><span class="w"> </span><span class="nl">supported</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">None</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">mask</span><span class="p">.</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">None</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">masking</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">explicitly</span><span class="w"> </span><span class="n">supported</span><span class="p">,</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">default</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">carry</span><span class="w"> </span><span class="k">over</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">input</span><span class="w"> </span><span class="n">mask</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mask</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="compute_output_shape">compute_output_shape</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_output_shape</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">input_shape</span>
<span class="p">)</span>
</code></pre></div>

<p>Computes the output shape of the layer.</p>
<p>If the layer has not been built, this method will call <code>build</code> on the
layer. This assumes that the layer will later be used with inputs that
match the input shape provided here.</p>
<p>Arguments:
    input_shape: Shape tuple (tuple of integers)
        or list of shape tuples (one per output tensor of the layer).
        Shape tuples can include None for free dimensions,
        instead of an integer.</p>
<p>Returns:
    An input shape tuple.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">compute_output_shape</span>(<span class="nb">self</span>, <span class="n">input_shape</span>):

    <span class="s">&quot;&quot;&quot;Computes the output shape of the layer.</span>

<span class="s">    If the layer has not been built, this method will call `build` on the</span>

<span class="s">    layer. This assumes that the layer will later be used with inputs that</span>

<span class="s">    match the input shape provided here.</span>

<span class="s">    Arguments:</span>

<span class="s">        input_shape: Shape tuple (tuple of integers)</span>

<span class="s">            or list of shape tuples (one per output tensor of the layer).</span>

<span class="s">            Shape tuples can include None for free dimensions,</span>

<span class="s">            instead of an integer.</span>

<span class="s">    Returns:</span>

<span class="s">        An input shape tuple.</span>

<span class="s">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">context</span>.<span class="n">executing_eagerly</span>():

      <span class="c1"># In this case we build the model first in order to do shape inference.</span>

      <span class="c1"># This is acceptable because the framework only calls</span>

      <span class="c1"># `compute_output_shape` on shape values that the layer would later be</span>

      <span class="c1"># built for. It would however cause issues in case a user attempts to</span>

      <span class="c1"># use `compute_output_shape` manually with shapes that are incompatible</span>

      <span class="c1"># with the shape the Layer will be called on (these users will have to</span>

      <span class="c1"># implement `compute_output_shape` themselves).</span>

      <span class="nb">self</span>.<span class="n">_maybe_build</span>(<span class="n">input_shape</span>)

      <span class="k">with</span> <span class="n">func_graph</span>.<span class="n">FuncGraph</span>(<span class="n">str</span>(<span class="nb">self</span>.<span class="nb">name</span>) + <span class="s">&#39;_scratch_graph&#39;</span>).<span class="n">as_default</span>():

        <span class="n">input_shape</span> = <span class="n">tf_utils</span>.<span class="n">convert_shapes</span>(<span class="n">input_shape</span>, <span class="n">to_tuples</span>=<span class="nb">False</span>)

        <span class="n">def</span> <span class="n">_make_placeholder_like</span>(<span class="nb">shape</span>):

          <span class="n">ph</span> = <span class="n">backend</span>.<span class="nb">placeholder</span>(<span class="nb">shape</span>=<span class="nb">shape</span>, <span class="n">dtype</span>=<span class="nb">self</span>.<span class="n">dtype</span>)

          <span class="n">ph</span>.<span class="n">_keras_mask</span> = <span class="n">None</span>

          <span class="k">return</span> <span class="n">ph</span>

        <span class="n">inputs</span> = <span class="n">nest</span>.<span class="n">map_structure</span>(<span class="n">_make_placeholder_like</span>, <span class="n">input_shape</span>)

        <span class="n">try:</span>

          <span class="n">outputs</span> = <span class="nb">self</span>(<span class="n">inputs</span>, <span class="n">training</span>=<span class="nb">False</span>)

        <span class="n">except</span> <span class="n">TypeError</span> <span class="n">as</span> <span class="n">e:</span>

          <span class="n">six</span>.<span class="n">raise_from</span>(

              <span class="n">NotImplementedError</span>(

                  <span class="s">&#39;We could not automatically infer the static shape of the &#39;</span>

                  <span class="s">&#39;layer\&#39;s output. Please implement the &#39;</span>

                  <span class="s">&#39;`compute_output_shape` method on your layer (%s).&#39;</span> %

                  <span class="nb">self</span>.<span class="n">__class__</span>.<span class="n">__name__</span>), <span class="nb">e</span>)

      <span class="k">return</span> <span class="n">nest</span>.<span class="n">map_structure</span>(<span class="n">lambda</span> <span class="n">t:</span> <span class="nb">t</span>.<span class="nb">shape</span>, <span class="n">outputs</span>)

    <span class="n">raise</span> <span class="n">NotImplementedError</span>(

        <span class="s">&#39;Please run in eager mode or implement the `compute_output_shape` &#39;</span>

        <span class="s">&#39;method on your layer (%s).&#39;</span> % <span class="nb">self</span>.<span class="n">__class__</span>.<span class="n">__name__</span>)
</code></pre></div>

</details>
<h5 id="compute_output_signature">compute_output_signature</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_output_signature</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">input_signature</span>
<span class="p">)</span>
</code></pre></div>

<p>Compute the output tensor signature of the layer based on the inputs.</p>
<p>Unlike a TensorShape object, a TensorSpec object contains both shape
and dtype information for a tensor. This method allows layers to provide
output dtype information if it is different from the input dtype.
For any layer that doesn't implement this function,
the framework will fall back to use <code>compute_output_shape</code>, and will
assume that the output dtype matches the input dtype.</p>
<p>Args:
  input_signature: Single TensorSpec or nested structure of TensorSpec
    objects, describing a candidate input for the layer.</p>
<p>Returns:
  Single TensorSpec or nested structure of TensorSpec objects, describing
    how the layer would transform the provided input.</p>
<p>Raises:
  TypeError: If input_signature contains a non-TensorSpec object.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@doc_controls.for_subclass_implementers</span>

  <span class="n">def</span> <span class="n">compute_output_signature</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_signature</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Compute the output tensor signature of the layer based on the inputs.</span>

<span class="s2">    Unlike a TensorShape object, a TensorSpec object contains both shape</span>

<span class="s2">    and dtype information for a tensor. This method allows layers to provide</span>

<span class="s2">    output dtype information if it is different from the input dtype.</span>

<span class="s2">    For any layer that doesn&#39;t implement this function,</span>

<span class="s2">    the framework will fall back to use `compute_output_shape`, and will</span>

<span class="s2">    assume that the output dtype matches the input dtype.</span>

<span class="s2">    Args:</span>

<span class="s2">      input_signature: Single TensorSpec or nested structure of TensorSpec</span>

<span class="s2">        objects, describing a candidate input for the layer.</span>

<span class="s2">    Returns:</span>

<span class="s2">      Single TensorSpec or nested structure of TensorSpec objects, describing</span>

<span class="s2">        how the layer would transform the provided input.</span>

<span class="s2">    Raises:</span>

<span class="s2">      TypeError: If input_signature contains a non-TensorSpec object.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="n">def</span> <span class="n">check_type_return_shape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">:</span>

      <span class="k">if</span> <span class="k">not</span> <span class="n">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tensor_spec</span><span class="p">.</span><span class="n">TensorSpec</span><span class="p">)</span><span class="o">:</span>

        <span class="n">raise</span> <span class="n">TypeError</span><span class="p">(</span>

            <span class="s1">&#39;Only TensorSpec signature types are supported, &#39;</span>

            <span class="s1">&#39;but saw signature signature entry: {}.&#39;</span><span class="p">.</span><span class="k">format</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

      <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">shape</span>

    <span class="n">input_shape</span> <span class="o">=</span> <span class="n">nest</span><span class="p">.</span><span class="n">map_structure</span><span class="p">(</span><span class="n">check_type_return_shape</span><span class="p">,</span> <span class="n">input_signature</span><span class="p">)</span>

    <span class="n">output_shape</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">compute_output_shape</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_compute_dtype</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="k">is</span> <span class="k">None</span><span class="o">:</span>

      <span class="n">input_dtypes</span> <span class="o">=</span> <span class="err">[</span><span class="n">s</span><span class="p">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">s</span> <span class="k">in</span> <span class="n">nest</span><span class="p">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">input_signature</span><span class="p">)</span><span class="err">]</span>

      <span class="c1"># Default behavior when self.dtype is None, is to use the first input&#39;s</span>

      <span class="c1"># dtype.</span>

      <span class="n">dtype</span> <span class="o">=</span> <span class="n">input_dtypes</span><span class="err">[</span><span class="mi">0</span><span class="err">]</span>

    <span class="k">return</span> <span class="n">nest</span><span class="p">.</span><span class="n">map_structure</span><span class="p">(</span>

        <span class="n">lambda</span> <span class="n">s</span><span class="o">:</span> <span class="n">tensor_spec</span><span class="p">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">s</span><span class="p">),</span>

        <span class="n">output_shape</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="count_params">count_params</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">count_params</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>

<p>Count the total number of scalars composing the weights.</p>
<p>Returns:
    An integer count.</p>
<p>Raises:
    ValueError: if the layer isn't yet built
      (in which case its weights aren't yet defined).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">count_params</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Count the total number of scalars composing the weights.</span>

<span class="s2">    Returns:</span>

<span class="s2">        An integer count.</span>

<span class="s2">    Raises:</span>

<span class="s2">        ValueError: if the layer isn&#39;t yet built</span>

<span class="s2">          (in which case its weights aren&#39;t yet defined).</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="k">not</span> <span class="n">self</span><span class="p">.</span><span class="n">built</span><span class="o">:</span>

      <span class="k">if</span> <span class="n">getattr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s1">&#39;_is_graph_network&#39;</span><span class="p">,</span> <span class="no">False</span><span class="p">)</span><span class="o">:</span>

        <span class="k">with</span> <span class="n">tf_utils</span><span class="p">.</span><span class="n">maybe_init_scope</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">:</span>

          <span class="n">self</span><span class="p">.</span><span class="n">_maybe_build</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">inputs</span><span class="p">)</span>

      <span class="k">else</span><span class="o">:</span>

        <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span><span class="s1">&#39;You tried to call `count_params` on &#39;</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="k">name</span> <span class="o">+</span>

                         <span class="s1">&#39;, but the layer isn</span><span class="se">\&#39;</span><span class="s1">t built. &#39;</span>

                         <span class="s1">&#39;You can build it manually via: `&#39;</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="k">name</span> <span class="o">+</span>

                         <span class="s1">&#39;.build(batch_input_shape)`.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">layer_utils</span><span class="p">.</span><span class="n">count_params</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">weights</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="get_config">get_config</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>

<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>    <span class="n">def</span> <span class="n">get_config</span><span class="p">(</span><span class="k">self</span><span class="p">):</span>

        <span class="n">base_config</span> <span class="o">=</span> <span class="n">super</span><span class="p">().</span><span class="n">get_config</span><span class="p">()</span>

        <span class="n">base_config</span><span class="p">[</span><span class="s1">&#39;anchor_ratios&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">self</span><span class="p">.</span><span class="n">_anchor_ratios</span>

        <span class="k">return</span> <span class="n">base_config</span>
</code></pre></div>

</details>
<h5 id="get_input_at">get_input_at</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_input_at</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node_index</span>
<span class="p">)</span>
</code></pre></div>

<p>Retrieves the input tensor(s) of a layer at a given node.</p>
<p>Arguments:
    node_index: Integer, index of the node
        from which to retrieve the attribute.
        E.g. <code>node_index=0</code> will correspond to the
        first time the layer was called.</p>
<p>Returns:
    A tensor (or list of tensors if the layer has multiple inputs).</p>
<p>Raises:
  RuntimeError: If called in Eager mode.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">get_input_at</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Retrieves the input tensor(s) of a layer at a given node.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        node_index: Integer, index of the node</span>

<span class="ss">            from which to retrieve the attribute.</span>

<span class="ss">            E.g. `node_index=0` will correspond to the</span>

<span class="ss">            first time the layer was called.</span>

<span class="ss">    Returns:</span>

<span class="ss">        A tensor (or list of tensors if the layer has multiple inputs).</span>

<span class="ss">    Raises:</span>

<span class="ss">      RuntimeError: If called in Eager mode.</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_get_node_attribute_at_index</span><span class="p">(</span><span class="n">node_index</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;input_tensors&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                                             </span><span class="s1">&#39;input&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="get_input_mask_at">get_input_mask_at</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_input_mask_at</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node_index</span>
<span class="p">)</span>
</code></pre></div>

<p>Retrieves the input mask tensor(s) of a layer at a given node.</p>
<p>Arguments:
    node_index: Integer, index of the node
        from which to retrieve the attribute.
        E.g. <code>node_index=0</code> will correspond to the
        first time the layer was called.</p>
<p>Returns:
    A mask tensor
    (or list of tensors if the layer has multiple inputs).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">get_input_mask_at</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Retrieves the input mask tensor(s) of a layer at a given node.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        node_index: Integer, index of the node</span>

<span class="ss">            from which to retrieve the attribute.</span>

<span class="ss">            E.g. `node_index=0` will correspond to the</span>

<span class="ss">            first time the layer was called.</span>

<span class="ss">    Returns:</span>

<span class="ss">        A mask tensor</span>

<span class="ss">        (or list of tensors if the layer has multiple inputs).</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">get_input_at</span><span class="p">(</span><span class="n">node_index</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">[</span><span class="n">getattr(x, &#39;_keras_mask&#39;, None) for x in inputs</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="k">else</span><span class="err">:</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getattr</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_keras_mask&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">None</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="get_input_shape_at">get_input_shape_at</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_input_shape_at</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node_index</span>
<span class="p">)</span>
</code></pre></div>

<p>Retrieves the input shape(s) of a layer at a given node.</p>
<p>Arguments:
    node_index: Integer, index of the node
        from which to retrieve the attribute.
        E.g. <code>node_index=0</code> will correspond to the
        first time the layer was called.</p>
<p>Returns:
    A shape tuple
    (or list of shape tuples if the layer has multiple inputs).</p>
<p>Raises:
  RuntimeError: If called in Eager mode.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">get_input_shape_at</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Retrieves the input shape(s) of a layer at a given node.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        node_index: Integer, index of the node</span>

<span class="ss">            from which to retrieve the attribute.</span>

<span class="ss">            E.g. `node_index=0` will correspond to the</span>

<span class="ss">            first time the layer was called.</span>

<span class="ss">    Returns:</span>

<span class="ss">        A shape tuple</span>

<span class="ss">        (or list of shape tuples if the layer has multiple inputs).</span>

<span class="ss">    Raises:</span>

<span class="ss">      RuntimeError: If called in Eager mode.</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_get_node_attribute_at_index</span><span class="p">(</span><span class="n">node_index</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;input_shapes&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                                             </span><span class="s1">&#39;input shape&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="get_losses_for">get_losses_for</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_losses_for</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span>
<span class="p">)</span>
</code></pre></div>

<p>Deprecated, do NOT use!</p>
<p>Retrieves losses relevant to a specific set of inputs.</p>
<p>Arguments:
  inputs: Input tensor or list/tuple of input tensors.</p>
<p>Returns:
  List of loss tensors of the layer that depend on <code>inputs</code>.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@doc_controls.do_not_generate_docs</span>

  <span class="n">def</span> <span class="n">get_losses_for</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Deprecated, do NOT use!</span>

<span class="s2">    Retrieves losses relevant to a specific set of inputs.</span>

<span class="s2">    Arguments:</span>

<span class="s2">      inputs: Input tensor or list/tuple of input tensors.</span>

<span class="s2">    Returns:</span>

<span class="s2">      List of loss tensors of the layer that depend on `inputs`.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">warnings</span><span class="p">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`layer.get_losses_for` is deprecated and &#39;</span>

                  <span class="s1">&#39;will be removed in a future version. &#39;</span>

                  <span class="s1">&#39;Please use `layer.losses` instead.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">losses</span>
</code></pre></div>

</details>
<h5 id="get_output_at">get_output_at</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_output_at</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node_index</span>
<span class="p">)</span>
</code></pre></div>

<p>Retrieves the output tensor(s) of a layer at a given node.</p>
<p>Arguments:
    node_index: Integer, index of the node
        from which to retrieve the attribute.
        E.g. <code>node_index=0</code> will correspond to the
        first time the layer was called.</p>
<p>Returns:
    A tensor (or list of tensors if the layer has multiple outputs).</p>
<p>Raises:
  RuntimeError: If called in Eager mode.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">get_output_at</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Retrieves the output tensor(s) of a layer at a given node.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        node_index: Integer, index of the node</span>

<span class="ss">            from which to retrieve the attribute.</span>

<span class="ss">            E.g. `node_index=0` will correspond to the</span>

<span class="ss">            first time the layer was called.</span>

<span class="ss">    Returns:</span>

<span class="ss">        A tensor (or list of tensors if the layer has multiple outputs).</span>

<span class="ss">    Raises:</span>

<span class="ss">      RuntimeError: If called in Eager mode.</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_get_node_attribute_at_index</span><span class="p">(</span><span class="n">node_index</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;output_tensors&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                                             </span><span class="s1">&#39;output&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="get_output_mask_at">get_output_mask_at</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_output_mask_at</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node_index</span>
<span class="p">)</span>
</code></pre></div>

<p>Retrieves the output mask tensor(s) of a layer at a given node.</p>
<p>Arguments:
    node_index: Integer, index of the node
        from which to retrieve the attribute.
        E.g. <code>node_index=0</code> will correspond to the
        first time the layer was called.</p>
<p>Returns:
    A mask tensor
    (or list of tensors if the layer has multiple outputs).</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">get_output_mask_at</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Retrieves the output mask tensor(s) of a layer at a given node.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        node_index: Integer, index of the node</span>

<span class="ss">            from which to retrieve the attribute.</span>

<span class="ss">            E.g. `node_index=0` will correspond to the</span>

<span class="ss">            first time the layer was called.</span>

<span class="ss">    Returns:</span>

<span class="ss">        A mask tensor</span>

<span class="ss">        (or list of tensors if the layer has multiple outputs).</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">get_output_at</span><span class="p">(</span><span class="n">node_index</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">isinstance</span><span class="p">(</span><span class="k">output</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="o">[</span><span class="n">getattr(x, &#39;_keras_mask&#39;, None) for x in output</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="k">else</span><span class="err">:</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getattr</span><span class="p">(</span><span class="k">output</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_keras_mask&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">None</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="get_output_shape_at">get_output_shape_at</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_output_shape_at</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">node_index</span>
<span class="p">)</span>
</code></pre></div>

<p>Retrieves the output shape(s) of a layer at a given node.</p>
<p>Arguments:
    node_index: Integer, index of the node
        from which to retrieve the attribute.
        E.g. <code>node_index=0</code> will correspond to the
        first time the layer was called.</p>
<p>Returns:
    A shape tuple
    (or list of shape tuples if the layer has multiple outputs).</p>
<p>Raises:
  RuntimeError: If called in Eager mode.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nv">@doc_controls</span><span class="p">.</span><span class="n">do_not_doc_inheritable</span><span class="w"></span>

<span class="w">  </span><span class="n">def</span><span class="w"> </span><span class="n">get_output_shape_at</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;Retrieves the output shape(s) of a layer at a given node.</span>

<span class="ss">    Arguments:</span>

<span class="ss">        node_index: Integer, index of the node</span>

<span class="ss">            from which to retrieve the attribute.</span>

<span class="ss">            E.g. `node_index=0` will correspond to the</span>

<span class="ss">            first time the layer was called.</span>

<span class="ss">    Returns:</span>

<span class="ss">        A shape tuple</span>

<span class="ss">        (or list of shape tuples if the layer has multiple outputs).</span>

<span class="ss">    Raises:</span>

<span class="ss">      RuntimeError: If called in Eager mode.</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">_get_node_attribute_at_index</span><span class="p">(</span><span class="n">node_index</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;output_shapes&#39;</span><span class="p">,</span><span class="w"></span>

<span class="w">                                             </span><span class="s1">&#39;output shape&#39;</span><span class="p">)</span><span class="w"></span>
</code></pre></div>

</details>
<h5 id="get_updates_for">get_updates_for</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_updates_for</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs</span>
<span class="p">)</span>
</code></pre></div>

<p>Deprecated, do NOT use!</p>
<p>Retrieves updates relevant to a specific set of inputs.</p>
<p>Arguments:
  inputs: Input tensor or list/tuple of input tensors.</p>
<p>Returns:
  List of update ops of the layer that depend on <code>inputs</code>.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="nv">@doc_controls.do_not_generate_docs</span>

  <span class="n">def</span> <span class="n">get_updates_for</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span><span class="o">:</span>

    <span class="s2">&quot;</span><span class="se">&quot;&quot;</span><span class="s2">Deprecated, do NOT use!</span>

<span class="s2">    Retrieves updates relevant to a specific set of inputs.</span>

<span class="s2">    Arguments:</span>

<span class="s2">      inputs: Input tensor or list/tuple of input tensors.</span>

<span class="s2">    Returns:</span>

<span class="s2">      List of update ops of the layer that depend on `inputs`.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

    <span class="k">warnings</span><span class="p">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;`layer.get_updates_for` is deprecated and &#39;</span>

                  <span class="s1">&#39;will be removed in a future version. &#39;</span>

                  <span class="s1">&#39;Please use `layer.updates` method instead.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">updates</span>
</code></pre></div>

</details>
<h5 id="get_weights">get_weights</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_weights</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>

<p>Returns the current weights of the layer.</p>
<p>The weights of a layer represent the state of the layer. This function
returns both trainable and non-trainable weight values associated with this
layer as a list of Numpy arrays, which can in turn be used to load state
into similarly parameterized layers.</p>
<p>For example, a Dense layer returns a list of two values-- per-output
weights and the bias value. These can be used to set the weights of another
Dense layer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = tf.keras.layers.Dense(1,
...   kernel_initializer=tf.constant_initializer(1.))
a_out = a(tf.convert_to_tensor([[1., 2., 3.]]))
a.get_weights()
[array([[1.],
       [1.],
       [1.]], dtype=float32), array([0.], dtype=float32)]
b = tf.keras.layers.Dense(1,
...   kernel_initializer=tf.constant_initializer(2.))
b_out = b(tf.convert_to_tensor([[10., 20., 30.]]))
b.get_weights()
[array([[2.],
       [2.],
       [2.]], dtype=float32), array([0.], dtype=float32)]
b.set_weights(a.get_weights())
b.get_weights()
[array([[1.],
       [1.],
       [1.]], dtype=float32), array([0.], dtype=float32)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Returns:
    Weights values as a list of numpy arrays.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">get_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Returns the current weights of the layer.</span>

<span class="sd">    The weights of a layer represent the state of the layer. This function</span>

<span class="sd">    returns both trainable and non-trainable weight values associated with this</span>

<span class="sd">    layer as a list of Numpy arrays, which can in turn be used to load state</span>

<span class="sd">    into similarly parameterized layers.</span>

<span class="sd">    For example, a Dense layer returns a list of two values-- per-output</span>

<span class="sd">    weights and the bias value. These can be used to set the weights of another</span>

<span class="sd">    Dense layer:</span>

<span class="sd">    &gt;&gt;&gt; a = tf.keras.layers.Dense(1,</span>

<span class="sd">    ...   kernel_initializer=tf.constant_initializer(1.))</span>

<span class="sd">    &gt;&gt;&gt; a_out = a(tf.convert_to_tensor([[1., 2., 3.]]))</span>

<span class="sd">    &gt;&gt;&gt; a.get_weights()</span>

<span class="sd">    [array([[1.],</span>

<span class="sd">           [1.],</span>

<span class="sd">           [1.]], dtype=float32), array([0.], dtype=float32)]</span>

<span class="sd">    &gt;&gt;&gt; b = tf.keras.layers.Dense(1,</span>

<span class="sd">    ...   kernel_initializer=tf.constant_initializer(2.))</span>

<span class="sd">    &gt;&gt;&gt; b_out = b(tf.convert_to_tensor([[10., 20., 30.]]))</span>

<span class="sd">    &gt;&gt;&gt; b.get_weights()</span>

<span class="sd">    [array([[2.],</span>

<span class="sd">           [2.],</span>

<span class="sd">           [2.]], dtype=float32), array([0.], dtype=float32)]</span>

<span class="sd">    &gt;&gt;&gt; b.set_weights(a.get_weights())</span>

<span class="sd">    &gt;&gt;&gt; b.get_weights()</span>

<span class="sd">    [array([[1.],</span>

<span class="sd">           [1.],</span>

<span class="sd">           [1.]], dtype=float32), array([0.], dtype=float32)]</span>

<span class="sd">    Returns:</span>

<span class="sd">        Weights values as a list of numpy arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>

    <span class="n">output_weights</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>

      <span class="k">if</span> <span class="n">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">base_layer_utils</span><span class="o">.</span><span class="n">TrackableWeightHandler</span><span class="p">):</span>

        <span class="n">output_weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">get_tensors</span><span class="p">())</span>

      <span class="k">else</span><span class="p">:</span>

        <span class="n">output_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">backend</span><span class="o">.</span><span class="n">batch_get_value</span><span class="p">(</span><span class="n">output_weights</span><span class="p">)</span>
</code></pre></div>

</details>
<h5 id="set_weights">set_weights</h5>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">set_weights</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">weights</span>
<span class="p">)</span>
</code></pre></div>

<p>Sets the weights of the layer, from Numpy arrays.</p>
<p>The weights of a layer represent the state of the layer. This function
sets the weight values from numpy arrays. The weight values should be
passed in the order they are created by the layer. Note that the layer's
weights must be instantiated before calling this function by calling
the layer.</p>
<p>For example, a Dense layer returns a list of two values-- per-output
weights and the bias value. These can be used to set the weights of another
Dense layer:</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = tf.keras.layers.Dense(1,
...   kernel_initializer=tf.constant_initializer(1.))
a_out = a(tf.convert_to_tensor([[1., 2., 3.]]))
a.get_weights()
[array([[1.],
       [1.],
       [1.]], dtype=float32), array([0.], dtype=float32)]
b = tf.keras.layers.Dense(1,
...   kernel_initializer=tf.constant_initializer(2.))
b_out = b(tf.convert_to_tensor([[10., 20., 30.]]))
b.get_weights()
[array([[2.],
       [2.],
       [2.]], dtype=float32), array([0.], dtype=float32)]
b.set_weights(a.get_weights())
b.get_weights()
[array([[1.],
       [1.],
       [1.]], dtype=float32), array([0.], dtype=float32)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>Arguments:
    weights: a list of Numpy arrays. The number
        of arrays and their shape must match
        number of the dimensions of the weights
        of the layer (i.e. it should match the
        output of <code>get_weights</code>).</p>
<p>Raises:
    ValueError: If the provided weights list does not match the
        layer's specifications.</p>
<details class="example"><summary>View Source</summary><div class="codehilite"><pre><span></span><code>  <span class="n">def</span> <span class="n">set_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Sets the weights of the layer, from Numpy arrays.</span>

<span class="sd">    The weights of a layer represent the state of the layer. This function</span>

<span class="sd">    sets the weight values from numpy arrays. The weight values should be</span>

<span class="sd">    passed in the order they are created by the layer. Note that the layer&#39;s</span>

<span class="sd">    weights must be instantiated before calling this function by calling</span>

<span class="sd">    the layer.</span>

<span class="sd">    For example, a Dense layer returns a list of two values-- per-output</span>

<span class="sd">    weights and the bias value. These can be used to set the weights of another</span>

<span class="sd">    Dense layer:</span>

<span class="sd">    &gt;&gt;&gt; a = tf.keras.layers.Dense(1,</span>

<span class="sd">    ...   kernel_initializer=tf.constant_initializer(1.))</span>

<span class="sd">    &gt;&gt;&gt; a_out = a(tf.convert_to_tensor([[1., 2., 3.]]))</span>

<span class="sd">    &gt;&gt;&gt; a.get_weights()</span>

<span class="sd">    [array([[1.],</span>

<span class="sd">           [1.],</span>

<span class="sd">           [1.]], dtype=float32), array([0.], dtype=float32)]</span>

<span class="sd">    &gt;&gt;&gt; b = tf.keras.layers.Dense(1,</span>

<span class="sd">    ...   kernel_initializer=tf.constant_initializer(2.))</span>

<span class="sd">    &gt;&gt;&gt; b_out = b(tf.convert_to_tensor([[10., 20., 30.]]))</span>

<span class="sd">    &gt;&gt;&gt; b.get_weights()</span>

<span class="sd">    [array([[2.],</span>

<span class="sd">           [2.],</span>

<span class="sd">           [2.]], dtype=float32), array([0.], dtype=float32)]</span>

<span class="sd">    &gt;&gt;&gt; b.set_weights(a.get_weights())</span>

<span class="sd">    &gt;&gt;&gt; b.get_weights()</span>

<span class="sd">    [array([[1.],</span>

<span class="sd">           [1.],</span>

<span class="sd">           [1.]], dtype=float32), array([0.], dtype=float32)]</span>

<span class="sd">    Arguments:</span>

<span class="sd">        weights: a list of Numpy arrays. The number</span>

<span class="sd">            of arrays and their shape must match</span>

<span class="sd">            number of the dimensions of the weights</span>

<span class="sd">            of the layer (i.e. it should match the</span>

<span class="sd">            output of `get_weights`).</span>

<span class="sd">    Raises:</span>

<span class="sd">        ValueError: If the provided weights list does not match the</span>

<span class="sd">            layer&#39;s specifications.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>

    <span class="n">expected_num_weights</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>

      <span class="k">if</span> <span class="n">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">base_layer_utils</span><span class="o">.</span><span class="n">TrackableWeightHandler</span><span class="p">):</span>

        <span class="n">expected_num_weights</span> <span class="o">+=</span> <span class="n">param</span><span class="o">.</span><span class="n">num_tensors</span>

      <span class="k">else</span><span class="p">:</span>

        <span class="n">expected_num_weights</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">expected_num_weights</span> <span class="o">!=</span> <span class="n">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>

      <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span>

          <span class="s1">&#39;You called `set_weights(weights)` on layer &quot;</span><span class="si">%s</span><span class="s1">&quot; &#39;</span>

          <span class="s1">&#39;with a weight list of length </span><span class="si">%s</span><span class="s1">, but the layer was &#39;</span>

          <span class="s1">&#39;expecting </span><span class="si">%s</span><span class="s1"> weights. Provided weights: </span><span class="si">%s</span><span class="s1">...&#39;</span> <span class="o">%</span>

          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">expected_num_weights</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">weights</span><span class="p">)[:</span><span class="mi">50</span><span class="p">]))</span>

    <span class="n">weight_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">weight_value_tuples</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>

      <span class="k">if</span> <span class="n">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">base_layer_utils</span><span class="o">.</span><span class="n">TrackableWeightHandler</span><span class="p">):</span>

        <span class="n">num_tensors</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">num_tensors</span>

        <span class="n">tensors</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">weight_index</span><span class="p">:</span><span class="n">weight_index</span> <span class="o">+</span> <span class="n">num_tensors</span><span class="p">]</span>

        <span class="n">param</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>

        <span class="n">weight_index</span> <span class="o">+=</span> <span class="n">num_tensors</span>

      <span class="k">else</span><span class="p">:</span>

        <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">weight_index</span><span class="p">]</span>

        <span class="n">ref_shape</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_shape</span><span class="o">.</span><span class="n">is_compatible_with</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>

          <span class="n">raise</span> <span class="n">ValueError</span><span class="p">(</span>

              <span class="s1">&#39;Layer weight shape </span><span class="si">%s</span><span class="s1"> not compatible with provided weight &#39;</span>

              <span class="s1">&#39;shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ref_shape</span><span class="p">,</span> <span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="n">weight_value_tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">param</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>

        <span class="n">weight_index</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">backend</span><span class="o">.</span><span class="n">batch_set_value</span><span class="p">(</span><span class="n">weight_value_tuples</span><span class="p">)</span>
</code></pre></div>

</details>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../pooling_ops/" title="Pooling Ops" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Pooling Ops
              </span>
            </div>
          </a>
        
        
          <a href="../../layers/" title="Index" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Index
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Powered by
        <a href="http://timothycrosley.github.io/portray">portray.</a>
        You too can
        <a href="http://timothycrosley.github.io/portray">
          portray</a>
        your Python project well using automatic documentation.
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../../../assets/javascripts/vendor.2d1db4bd.min.js"></script>
      <script src="../../../../../assets/javascripts/bundle.6627ddf3.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../../../../..",
          features: [],
          search: Object.assign({
            worker: "../../../../../assets/javascripts/worker/search.5eca75d3.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>